# 一些问题

## 1. null和undefined的区别

```js
console.log(null==undefined)//true
console.log(null===undefined)//false
```

原因：

1. null： Null类型，代表“空值”，代表一个空对象指针，使用 `typeof` 运算得到 “object”，所以你可以认为它是一个特殊的对象值。
2. undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。

使用时间：

 null表示"没有对象"，即该处不应该有值。典型用法是：

（1） 作为函数的参数，表示该函数的参数不是对象。

（2） 作为对象原型链的终点。

undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：

（1）变量被声明了，但没有赋值时，就等于undefined。

（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。

（3）对象没有赋值的属性，该属性的值为undefined。

（4）函数没有返回值时，默认返回undefined。

注：null和undefined是所有类型的子类型

## 2. 为什么使用typescript

TypeScript是JavaScript的超集，具有可选的类型并可以编译为纯JavaScript。从技术上讲TypeScript就是具有静态类型的 JavaScript 。

他有以下3个优点：

1. 可以避免经典的错误 `'undefined' is not a function.`
2. 在不严重破坏代码的情况下，重构代码更容易。
3. 使大型、复杂的应用程序源码更易阅读。

动态类型的自由特性经常会导致错误，这些错误不仅会降低程序员的工作效率，而且还会由于增加新代码行的成本增加而使开发陷入停顿。

因此，JavaScript无法合并类型以及编译时缺乏错误检查，使它不适合作为企业和大型代码库中服务器端代码。

## 3.Object知识点汇总

### js中Object的定义

区分Object和Object()：

1. Object是原型对象，它来自于 new Object()。

2. Object()是构造函数创建一个对象包装器。本质上就是原型对象的构造函数

3. 当以非构造函数形式被调用时，Object 等同于 new Object()。即
   var o = Object() 和var o = Object 效果是一样的。

4. 语法：

   ```js
   // 对象初始化器（Object initialiser）或对象字面量（literal）
   { [ nameValuePair1[, nameValuePair2[, ...nameValuePairN] ] ] }
   
   // 以构造函数形式来调用
   new Object([value])
   
   //三种方式创建对象
   let o = Object;
   let oj = new Object;
   
   let obj = {
       name:"cc",
       age:25,
       do:function(str){
           console.log(`我是${this.name},我在${str}`)
       }
   }
   
   ```

### Object属性：

1. **Object.prototype**：可以为所有 Object [类型](https://so.csdn.net/so/search?q=类型&spm=1001.2101.3001.7020)的对象添加属性。**要为原型对象扩展方法或者属性就必须在prototype上**,只有这样其他所有继承自Object的对象实例才能共有这个方法，这也是js实现继承的根基。
2. **Object.length**：Object.length 值为1，该属性基本没有什么用处。

### Object 构造函数的方法：

1. Object.assign()

   - `Object.assign()` 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。
   - 语法：`Object.assign(target,...sources)`
   - 参数：`target`目标对象，`sources`源对象
   - 返回值：目标对象
   - 描述：如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。`Object.assign` 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的`[[Get]]`和目标对象的`[[Set]]`，所以它会调用相关 getter 和 setter。

2. Object.create()

   - 定义 ：使用指定的原型对象和属性创建一个新对象。使用现有的对象来提供新创建的对象的 `__proto__`。

   - 语法：`Object.create(proto[, propertiesObject])`
   - 参数：proto新创建对象的原型对象。

   - propertiesObject可选。如果没有指定为 undefined，则是要添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。

3. Object.defineProperty()

   - 定义：给对象添加一个属性并指定该属性的配置。方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。

   - 语法：`Object.defineProperty(obj, prop, descriptor)`

   - 参数：
     - `obj` 要在其上定义属性的对象。
     - `prop` 要定义或修改的属性的名称。
     - `descriptor` 将被定义或修改的属性描述符。
       - `configurable`：当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。
       - `enumerable`：当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。
       - `writable`：当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。
       - `get`：作为该属性的 getter 函数，如果没有 getter 则为[`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。函数返回值将被用作属性的值。
       - `set`：作为属性的 setter 函数，如果没有 setter 则为[`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。函数将仅接受参数赋值给该属性的新值

4. Object.defineProperties()

   - 给对象添加多个属性并分别指定它们的配置。用法与3相同

5. Object.entries()

   - 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。

6. Object.keys()

   - 返回一个包含所有给定对象自身可枚举属性名称的数组，返回一个所有元素为字符串的数组，其元素来自于从给定的object上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。

## 4.Async和Await

### 作用

`async`和`await`是用来处理异步的。即你需要异步像同步一样执行，需要异步返回结果之后，再往下依据结果继续执行。
`async` 是“异步”的简写，而 `await` 可以认为是 `async wait` 的简写。
`async` 用于申明一个 `function` 是异步的，而 `await` 用于等待一个异步方法执行完成。

### async

```js
async function testAsync() {
    return "hello async";
}

const result = testAsync();
console.log(result);

testAsync().then(v => {
    console.log(v);    // 输出 hello async
});

```

打印输出的是一个`Promise` 对象，`async` 函数会返回一个 `Promise` 对象。
在最外层不能用 `await` 获取其返回值的情况下，使用 `then()` 链来处理这个 `Promise` 对象。

### await

**`await`只能放在`async`函数内部使用**

`await` 用于一个异步操作之前，表示要“等待”这个异步操作的返回值。

`await` 也可以用于一个同步的值。

如果它等到的不是一个 `Promise` 对象，那 await 表达式的运算结果就是它等到的东西。

如果它等到的是一个 `Promise` 对象，`await` 就会阻塞后面的代码，等着 `Promise` 对象 `resolve`，然后得到 `resolve` 的值，作为 `await` 表达式的运算结果。

```js
// 2s 之后返回双倍的值
function doubleAfter2seconds(num) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(2 * num)
        }, 2000);
    })
}

async function testResult () {
    let result = await doubleAfter2seconds(30);
    console.log(result);
}

testResult();
// 2s 之后，输出了60. 
```

### 执行顺序

案例一：

```js
// 2s 之后返回双倍的值
function doubleAfter2seconds(num) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(2 * num)
        }, 2000);
    })
}

async function testResult () {
    console.log('内部调用前') // 2
    let result = await doubleAfter2seconds(30);
    console.log(result); // 4
    console.log('内部调用后') // 5
}

console.log('外部调用前') // 1
testResult();
console.log('外部调用后') // 3
// --- 依次输出
// 外部调用前
// 内部调用前
// 外部调用后
// --- 2s 之后输出
// 60
// 内部调用后

```

分析一下上面的执行顺序：
1、首先打印输出`外部调用前`，同步代码，顺序执行。
2、然后调用方法`testResult()`，打印输出`内部调用前`，同步代码，顺序执行。
3、再执行异步方法`doubleAfter2seconds`，
　1>如果没用`await`关键字，此后的执行顺序应该是
　　`内部调用后`，`外部调用后`，`2s 之后输出60`
　　因为异步方法不阻塞其他代码的执行，最后再输出`60`
　2>这里使用了`await`关键字，所以到这里后会等待异步返回结果，再往下执行。
4、当`testResult`函数内部`await`阻塞执行后，不会影响到`testResult`函数外面

**`async` 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 `Promise` 对象中异步执行。**

所以，在调用`testResult`函数后，会继续向下执行，打印输出`外部调用后`
5、当2s之后，异步函数`doubleAfter2seconds`执行完成，返回结果，
打印输出`60`
6、因为`await`将异步变成同步，所以在输出`60`后，同步执行，再输出`内部调用后`

案例二：

```js
setTimeout(function () {
    console.log("1");
  }, 0);//8 异步最后执行
  async function async1() {
    console.log("2");//1
    const data = await async2();//接收"async2的结果"
    console.log("3");//5
    return data;
  }
  async function async2() {
    return new Promise((resolve) => {
      console.log("4");//2
      resolve("async2的结果");//异步执行
    }).then((data) => {
      console.log("5");//4
      return data;
    });
  }
  async1().then((data) => {
    console.log("6");//6
    console.log(data);//7 async2的结果
  });
  new Promise(function (resolve) {
    console.log("7");//3
    //   resolve()
  }).then(function () {
    console.log("8");
  });
  //2 4 7 5 3 6 async2的结果 1
```

分析：

1. 首先打印 2 ，`setTimeOut` 为异步代码，最后执行
2. 再执行异步方法`async2`，这里使用了`await`关键字，所以到这里后会等待异步返回结果，再往下执行。
3. 执行 `async2`，返回一个promise对象，先执行 `console.log("4")`同步代码，then方法在同步代码执行完毕后调用
4. 执行 `new Promise`，打印7，返回执行 async2的then方法，打印5
5. asyc2 执行完毕返回async1执行后续代码打印3
6. 执行 `async1.then()` ,打印6和async2的结果
7. 最后执行 `setTimeOut`,打印1

## 5.事件循环

### 任务队列

所有的任务可以分为同步任务和异步任务，同步任务，顾名思义，就是立即执行的任务，同步任务一般会直接进入到主线程中执行；而异步任务，就是异步执行的任务，比如ajax网络请求，setTimeout 定时函数等都属于异步任务，异步任务会通过任务队列( Event Queue )的机制来进行协调。具体的可以用下面的图来大致说明一下：

![image-20220303201937020](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220303201937020.png)

同步和异步任务分别**进入不同的执行环境**，同步的进入主线程，即主执行栈，异步的进入 Event Queue 。主线程内的任务执行完毕为空，会去 Event Queue 读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。

在事件循环中，每进行一次循环操作称为tick，通过阅读规范可知，每一次 tick 的任务处理模型是比较复杂的，其关键的步骤可以总结如下：

1. 在此次 tick 中选择最先进入队列的任务( oldest task )，如果有则执行(一次)
2. 检查是否存在 Microtasks ，如果存在则不停地执行，直至清空Microtask Queue
3. 更新 render
4. 主线程重复执行上述步骤

可以用一张图来说明下流程：

![image-20220303202118701](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220303202118701.png)

(macro)task 主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)

microtask主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)

setTimeout/Promise 等API便是任务源，而进入任务队列的是由他们指定的具体执行任务。来自不同任务源的任务会进入到不同的任务队列。其中 setTimeout 与 setInterval 是同源的。

### 案例

```js

console.log('script start');//1

setTimeout(function() {
  console.log('timeout1');//5
}, 10);

new Promise(resolve => {
    console.log('promise1');//2
    resolve();
    setTimeout(() => console.log('timeout2'), 10);//6
}).then(function() {
    console.log('then1')//4
})

console.log('script end');//3

```

分析：

![image-20220303202835609](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220303202835609.png)

有个小 tip：**从规范来看，microtask 优先于 task 执行，所以如果有需要优先执行的逻辑，放入microtask 队列会比 task 更早的被执行**。

## 6.将string转换为number的方法

1. 第一种方法：使用Number()函数

2. 第二种方法：使用parseInt()或者parseFloat()

3. 第三种方法：隐式转换1

   第一种隐式转换，就是使用运算符减、乘、除的其中一种，在不改变原值的情况下，和[number类](https://so.csdn.net/so/search?q=number类&spm=1001.2101.3001.7020)型的值做运算

   - 若字符串中的是纯数字，则直接返回该数值
   - 若字符串中不是纯数字，则返回NaN
   - 若字符串为空，则返回0
   - 转换布尔型，则true返回1，false返回0
   - 转换undefined，则返回NaN

   第二种隐式转换，就是在被转换的值前边，加入一个负号，或者正号

   - 但是若使用负号，则浏览器会对值进行取反，此时需要在前边再加一个负号，不过需要用括号将两个负号分开，或者需要将值加一，即写成 -(-a)或者-a+1

## 7.理解同步异步

### 同步

同步就是我强依赖你(对方)，我必须等到你的回复，才能做出下一步响应。即我的操作(行程)是顺序执行的，中间少了哪一步都不可以，或者说中间哪一步出错都不可以，类似于编程中程序被解释器顺序执行一样；同时如果我没有收到你的回复，我就一直处于等待、也就是阻塞的状态。 

### 异步

异步则相反，我并不强依赖你，我对你响应的时间也不敏感，无论你返回还是不返回，我都能继续运行；你响应并返回了，我就继续做之前的事情，你没有响应，我就做其他的事情。也就是说我不存在等待对方的概念，我就是非阻塞的。

**阻塞和非阻塞强调的是程序在等待调用结果（消息，返回值）时的状态**

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 对于同步调用来说，很多时候当前线程还是激活的状态，只是从逻辑上当前函数没有返回而已，即同步等待时什么都不干，白白占用着资源

**同步和异步强调的是消息通信机制**

所谓同步，就是在发出一个"调用"时，在没有得到结果之前，该“调用”就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由“调用者”主动等待这个“调用”的结果。而异步则是相反，"调用"在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在"调用"发出后，"被调用者"通过状态、通知来通知调用者，或通过回调函数处理这个调用。

## 8.Map类型

`Map()`构造方法

`size`成员方法，返回map的大小

- CRUD（增删改查）

  `set(key,value)`新增键值对、修改值

  `has(key) - boolean `是否含有key

  `get(key)`获取key的值

  `delete(key)`删除

  `clear()`清空

- 遍历相关

  `map.keys() -Map Iterator` 返回map的键迭代器。

  `map.values() -Map Iterator` 值迭代器。

  `map.entries(o) -Map Iterator` 键值对迭代器。

  `map.forEach(callbackFn, ?thisArg)` forEach()对容器中每个元素(键值对)执行callbackFn。
  callbackFn函数声明：function(value, key) {...}，注意参数顺序。

## 9.4种for循环

### 简单for循环

循环代码块一定次数

```js
const arr = [1, 2, 3];
for(let i = 0, len = arr.length; i < len; i++) {
    console.log(arr[i]);
}
```

### for-in循环

循环遍历对象和原型链上的属性（只能遍历“可枚举的属性”）

```js
const arr = [1, 2, 3];
let index;//其中index为属性名所以是string类型
for(index in arr) {
    console.log("arr[" + index + "] = " + arr[index]);
}
// 输出结果如下
// arr[0] = 1 
// arr[1] = 2 
// arr[2] = 3
```

```js
Array.prototype.fatherName = "Father";
const arr = [1, 2, 3];
arr.name = "Hello world";
let index;
for(index in arr) {
    console.log("arr[" + index + "] = " + arr[index]);
}
// arr[0] = 1
// arr[1] = 2
// arr[2] = 3
// arr[name] = Hello world
// arr[fatherName] = Father
```

### foreach

es5引入的新循环

**forEach是不能阻塞的，默认是请求并行发起**

forEach 方法为数组中含有有效值的每一项执行一次 callback 函数，那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）。callback 函数会被依次传入三个参数：

- 数组当前项的值；
- 数组当前项的索引；
- 数组对象本身；

### for-of

es6引入的新循环

ES6之前的 3 种 for 循环有什么缺陷：

- forEach 不能 break 和 return；
- for-in 缺点更加明显，它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。而且，遍历数组元素的顺序可能是随机的。

for-of 作用

- 跟 forEach 相比，可以正确响应 break, continue, return。
- for-of 循环不仅支持数组，还支持大多数类数组对象，例如 DOM nodelist 对象。
- for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。
- for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历。

## 10.js去除字符串空格

### replace正则匹配法

1. 去除字符串内所有的空格：str = str.replace(/\s*/g,"");
2. 去除字符串内两头的空格：str = str.replace(/^\s*|\s*$/g,"");
3. 去除字符串内左侧的空格：str = str.replace(/^\s*/,"");
4. 去除字符串内右侧的空格：str = str.replace(/(\s*$)/g,"");

### str.trim()

trim()方法是用来删除字符串两端的空白字符并返回，trim方法并不影响原来的字符串本身，它返回的是一个新的字符串。

缺陷：只能去除字符串两端的空格，不能去除中间的空格

## 11.深拷贝和浅拷贝

深浅拷贝只针对于引用类型而言

因为引用类型的名存于栈内存中，值存于堆内存中，栈内存会提供一个引用的地址指向堆内存中的值

![image-20220323112559257](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220323112559257.png)

当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。

![image-20220323112629429](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220323112629429.png)

而当我们**a[0]=1**时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。

​	 		![image-20220323112742777](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220323112742777.png)

要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，就达到深拷贝的效果了

​				![image-20220323112850215](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220323112850215.png)

### 实现深拷贝代码

```js
// 递归实现深拷贝
function deepClone(target){
  // 声明一个存放结果的变量
  let result 
  // 判断目标是否是一个Object对象
  if(typeof target === 'object'){
    // 判断目标是否是一个数组
    if(Array.isArray(target)){
      result = []
      for(let i in target){
        // 递归调用
        result.push(deepClone(target[i]))
      }
    }else if(target === null){
      result = target
      // 判断是否是正则对象
    }else if(target.constructor === RegExp) {
      result = target
      // 判断是否是日期对象
    }else if(target.constructor === Date) {
      result = target
      // 判断是否是错误对象  
    }else if(target.constructor === Error) {
      result = target
    }else {
      result = {}
      for(let i in target){
        result[i] = deepClone(target[i])
      }
    }
    // 判断目标是否是一个函数对象
  }else if (typeof target === 'function'){
    // 如果是函数
    result = new Function('return' + target.toString())
  }else{
    // 如果是基本数据类型
    result = target
  }
  return result
}
```

### 拷贝数据的方式

1. 直接赋值给一个变量

2. Object.assign() 浅拷贝

3. Array.prototype.slice() 深拷贝

4. Array.prototype.concat() 深拷贝

5. JSON.parse(JSON.stringify()) 深拷贝

   JSON.parse问题

   -   时间对象变成字符串
   -   RegExp和Error对象会变成空对象
   -   函数和undefied会丢失
   -   有NaN，infinity为变成nul
   -   如果对象由构造函数生成会丢失constructor属性的指向，指向Object

6. Loadsh库中的API，如：.clone()、.cloneDeep()

7. 扩展运算符…arr 深拷贝

## 12.手写instanceof

判断一个实例是否是其父类或者祖先类型的实例。

instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype查找失败，返回 false

```js
let myInstanceof = (target,origin) =>{
	while(target){
        if(target.__proto__ === origin.prototype){
            return true
        }
        target = target.__proto__
    }
    return false
}
```

## 13.实现数组map()方法

map()经常用来遍历数据。

map()的作用就是“映射”，也就是原数组被“映射”成对应新数组。

1.  方法概述

   map() 方法返回一个新数组，这个新数组：由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。

   map() 不会对空数组进行检测。

   map() 不会改变原始数组。

2. 代码实现

   ```js
   Array.prototype.map = function(fn){
       let res = []
       let arr = this
       for(let i in arr){
        // 三个参数  
        // currentValue必须:当前元素的值
        // index可选:当前元素的索引值
        // arr可选:当前元素属于的数组对象
           res.push(fn(arr[i],i,this))
       }
       return res
   }
   ```

## 14.手写reduce方法

reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终为一个值，是ES5中新增的又一个数组逐项处理方法

**参数：**

- callback（一个在数组中每一项上调用的函数，接受四个函数：）

- - previousValue（上一次调用回调函数时的返回值，或者初始值）
  - currentValue（当前正在处理的数组元素）
  - currentIndex（当前正在处理的数组元素下标）
  - array（调用reduce()方法的数组）

- callback是 reduce 方法多次执行的累积结果，callback 的初始值分两种情况：

  - 若有提供 initialValue 初始值，第一次循环时 callback 的值便为 initialValue，后续循环时 callback 为上次循环的返回值。

  - 若未提供initialValue，第一次循环时 callback 的值为数组第一项arr[0]，后续循环时为上次循环的返回值。

- initialValue（可选的初始值。作为第一次调用回调函数时传给previousValue的值）

**代码**：

```js
Array.prototype.myReduce = function(fn,initialVal){
    let acc = initialVal ? initialVal : this[0]
    let startIndex = initialVal ? 0:1
    for(let i = startIndex;i<this.length;i++){
        acc = fn(acc,this[i],i,this)
    }
    return acc
}
```

## 15.数组扁平化

将多维数组转换为一维数组

1. 使用es6的新方法flat：flat(depth)

   ```js
   let a = [1,[2,3]]; 
   a.flat(); // [1,2,3] 
   a.flat(1); //[1,2,3]
   ```

   使用flat(Infinity)，无需知道数组维度，直接转换为一维数组

   ```js
   let a = [1,[2,3,[4,[5]]]]; 
   a.flat(Infinity); // [1,2,3,4,5]  a是4维数组
   ```

2. 使用concat方法

   ```js
   function flatten(arr){
   	let res = []
       for(let i = 0,len = arr.length;i<len;i++){
           if(Array.isArray(arr[i])){
               res = res.concat(flatten(arr[i]))
           }else{
               res.push(arr[i])
           }
       }
       return res
   }
   ```

## 16.实现函数柯里化

柯里化的定义：接收一部分参数，返回一个函数接收剩余参数，接收足够参数后，执行原函数。

柯里化的优点：

1. 参数复用

2. 提高适用性

   ```js
   //通用函数解决了兼容性的问题，但是同时在不同场景下，我们可能同一种规则需要反复使用
   //这就可能会造成代码的重复性 比如
   
   function square(i){ return i*i }//平方
   function dubble(i){ return i*2 }//双倍
   function map(handler,list){
   	//handle 是操作的规则 list是操作的arrguments
   	return list.map(handler)
   }
   
   map(square,[1,2,3]);//数组每一项平方
   map(dubble,[1,2,3]);//数组每一项加倍
   //这就是通用性 我可以用同一个函数做很多不同的操作
   //但是如果我们需要大量做平方操作 每次我们都需要传入方法再传入数组就造成的代码浪费
   //这时我们通过柯里化提高实用性
   
   let mapSQ = currying(map,square);//直接定义出来的新的平凡操作函数
   mapSQ([1,2,3]);//以后就不用传入操作方法了
   ```

3. 延迟执行

当柯里化函数接收到足够参数后，就会执行原函数，如何去确定何时达到足够的参数呢？

有两种思路：

1. 通过函数的 length 属性，获取函数的形参个数，形参的个数就是所需的参数个数

2. 在调用柯里化工具函数时，手动指定所需的参数个数

   ```js
   /**
    * 将函数柯里化
    * @param fn    待柯里化的原函数
    * @param len   所需的参数个数，默认为原函数的形参个数
    */
   function curry(fn,len = fn.length){
     return _curry.call(this,fn,len)
   }
   
   /**
    * 中转函数
    * @param fn    待柯里化的原函数
    * @param len   所需的参数个数
    * @param args  已接收的参数列表
    */
   function _curry(fn,len,...args){
     return function(...params){
       let _args = [...args,...params]
       if(_args.length >= len) {
         return fn.apply(this,_args)
       }else{
         return _curry.call(this,fn,len,..._args)
       }
     }
   }
   ```

## 17.理解js中的this指向

**this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁**，**实际上this的最终指向的是那个调用它的对象**

1. 如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window。

   ```js
   function a() {
       var user = "追梦子";
       console.log(this.user); //undefined
       console.log(this); //Window
   }
   a();
   ```

2. 如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。

   ```js
   var o = {
       user:"追梦子",
       fn:function(){
           console.log(this.user);  //追梦子
       }
   }
   o.fn();
   ```

3. 如果一个函数中有this，**这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象**

   ```js
   var o = {
       a:10,
       b:{
           a:12,
           fn:function(){
               console.log(this.a); //12
           }
       }
   }
   o.b.fn();
   ```

4. 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例

   ```js
   function Fn()  
   {  
       this.user = '追梦子';  
    	// 返回值为一个空对象   
       return {};  
       // return function(){}
   }
   var a = new Fn;  
   console.log(a.user); //undefined
   
   function Fn()  
   {  
       this.user = '追梦子';  
       return 1;
   }
   var a = new Fn;  
   console.log(a.user); //追梦子
   function Fn()  
   {  
       this.user = '追梦子';  
       return undefined;
   }
   var a = new Fn;  
   console.log(a.user); //追梦子
   ```

## 18.js中的call()，apply()，bind()

​	都是用于改变this指向

1. call()

   ```js
   var a = {
       user:"追梦子",
       fn:function(){
           console.log(this.user); //追梦子
       }
   }
   // 定义b为a对象中的函数
   var b = a.fn;
   b.call(a);
   ```

   通过在call方法，给第一个参数添加要把b添加到哪个环境中，简单来说，this就会指向那个对象。

   call方法除了第一个参数以外还可以添加多个参数，如下：

   ```js
   var a = {
       user:"追梦子",
       fn:function(e,ee){
           console.log(this.user); //追梦子
           console.log(e+ee); //3
       }
   }
   var b = a.fn;
   b.call(a,1,2);
   ```

2. apply()

   apply方法和call方法有些相似，它也可以改变this的指向，同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组

   ```js
   var a = {
       user:"追梦子",
       fn:function(e,ee){
           console.log(this.user); //追梦子
           console.log(e+ee); //11
       }
   }
   var b = a.fn;
   b.apply(a,[10,1]);
   ```

   //注意如果call和apply的第一个参数写的是null，那么this指向的是window对象

3. bind()

   和apply、call一样用来改变this的指向，不同的是bind返回一个修改过后的函数

   同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。

   ```js
   var a = {
       user:"追梦子",
       fn:function(){
           console.log(this.user);
       }
   }
   var b = a.fn;
   var c = b.bind(a);
   console.log(c); //function() { [native code] }
   c()// 才进行打印
   ```

## 19.手写call、apply、bind

1. 手写call

   ```js
   // 将方法添加在Function原型上
   Function.prototype.myCall = (context=window){
       // 这里if其实没必要，会自动抛出错误
       if(typeof this !== 'function'){
           throw new Error('不是函数')
       }else{
           //这里可用ES6方法，为参数添加默认值，js严格模式全局作用域this为undefined
           const obj = context || window
           //this为调用的上下文,this此处为函数，将这个函数作为obj的方法
           obj.fn = this
           //第一个为obj所以删除,伪数组转为数组
           const arg = [...arguments].slice(1)
           let res = obj.fn(arg)
           // 不删除会导致context属性越来越多
           delete obj.fn
           return res
       }
   }
   ```

2. 手写apply

   ```js
   Function.prototype.myApply = function(context){
   	const obj = context || window
       obj.fn = this
       const arg = arguments[1]||[]
       let res = obj.fn(...arg)
       delete obj.fn
       return res
   }
   ```

3. 手写bind

   ```js
   Function.prototype.myBind = function(context){
   	// 对context 进行深拷贝，避免在bind执行后返回函数未执行时context发生变化
       const obj = JSON.parse(JSON.stringify(context)) || window
       obj.fn = this
       // 获取当前参数列表
       const args = [...arguments].slice(1)
       return function(){
           let allArgs = args.concat([...arguments])
           return allArgs.length >0 ? obj.fn(allArgs) : obj.fn()
       }
   }
   ```

## 20.手写实现new

new的过程文字描述：

1. 创建一个空对象 obj;
2. 将空对象的隐式原型（`__proto__`）指向构造函数的prototype。
3. 使用 call 改变 this 的指向
4. 如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。

```js
function create(){
    // 创建一个空对象 obj
	let obj = {}
    // 获取构造函数
    let args = [...arguments]
    let fn = args.shift()
    // 将空对象的隐式原型（__proto__）指向构造函数的prototype。
    obj.__proto__ = fn.prototype
    // 使用 apply 改变 this 的指向
    let res = fn.apply(obj,arguments)
    return typeof res === 'object'?res:obj
}
```

## 21.手写一个Promise对象

1. Promise对象的基本结构

   ```js
   function Promise(executor){
   	this.state = 'pending' //定义状态
       this.value = undefine //保存成功的值
       this.reason = undefine //保存失败的原因
       // 成功时执行的方法
       function resolve(value){
           
       }
       // 失败时执行的方法
       function reject(reason){
           
       }    
   }
   ```

2. 每一个Promise实例都有一个then方法，它用来处理异步返回的结果，它是定义在原型上的方法，

   ```js
   // promise对象的then方法
   Promise.prototype.then = function(onFulfilled,onRejected){
   
   }
   ```

3. 当实例化Promise时会立即执行

   ```js
   function Promise(executor) {
       var _this = this;
       this.state = 'pending';
       this.value = undefined;
       this.reason = undefined;
   
       executor(resolve, reject); //马上执行
       
       function resolve(value) {}
       function reject(reason) {}
   }
   ```

4. 规范中规定，当Promise对象已经由pending状态改变为了成功态（resolved）或是失败态（rejected）就不能再次更改状态了。因此我们在更新状态时要判断，如果当前状态是pending（等待态）才可更新：

   ```js
   // 成功时执行的方法
   function resolve(value){
   	if(_this.state === 'pending'){
           _this.value = value // 保存成功的结果
           _this.state = 'resolved'
       }
   }
   // 失败时执行的方法
   function reject(reason){
       if(_this.state === 'pending'){
           _this.reason = reason
           _this.state = 'rejected'
       }
   }    
   ```

5. then方法的基本实现

   ```js
   // promise对象的then方法
   Promise.prototype.then = function(onFulfilled,onRejected){
   	if(this.state === 'resolved'){
           if(typeof onFulfilled === 'function'){
               onFulfilled(this.value)
           }
       }
       if(this.state === 'rejected'){
           if(typeof onRejected === 'function'){
               onRejected(this.reason)
           }
       }
   }
   ```

6. 让Promise支持异步：我们可以参照发布订阅模式，在执行then方法时如果还在等待态（pending），就把回调函数临时寄存到一个数组里，当状态发生改变时依次从数组中取出执行就好了

   ```js
   function Promise(executor){
   	var _this = this
       this.state = 'pending'
       this.value = undefined
       this.reason = undefined
       this.onFulfilledFunc = []
       this.onRejectedFunc = []
       
       executor(resolve,reject)
       
       function resolve(value){
           if(_this.state === 'pending'){
               this.value = value
               this.onFulfilledFunc.forEach(fn => fn(value))
               this.state = 'resolved'
           }
       }
       
       function reject(reason){
           if(_this.state === 'pending'){
               _this.reason = reason
               _this.onRejectedFunc.forEach(fn => fn(reason))
               _this.state = 'rejected'
           }
       }
       
       Promise.prototype.then = function(onFulfilled,onRejected){
           if(this.state = 'pending'){
               if(typeof onFulfilled === 'function'){
                   this.onFulfilledFunc.push(onFulfilled)//保存回调
               }
               if(typeof onRejected === 'function'){
                   this.onRejectedFunc.push(onRejected)//保存回调
               }
           }
       }
   }
   ```

7. 实现链式调用

   - 首先，不论何种情况then都返回Promise对象，我们就实例化一个新promise2并返回。

     ```js
     Promise.prototype.then(onFulfilled,onRejected){
     	var promise2 = new Promise((resolve,reject)=>{
             
         })
         return promise2
     }
     ```

   - 处理根据上一个then方法的返回值来生成新Promise对象，由于这块逻辑较复杂且有很多处调用，我们抽离出一个方法来操作

     ```js
     /**
      * 解析then返回值与新Promise对象
      * @param {Object} promise2 新的Promise对象 
      * @param {*} x 上一个then的返回值
      * @param {Function} resolve promise2的resolve
      * @param {Function} reject promise2的reject
      */
     function resolvePromise(promise2, x, resolve, reject) {
         //...
     }
     ```

   - `resolvePromise`方法用来封装链式调用产生的结果，下面我们分别一个个情况的写出它的逻辑，首先规范中说明，如果`promise2`和 `x` 指向同一对象，就使用TypeError作为原因转为失败。如果返回了自己的Promise对象，状态永远为等待态（pending），再也无法成为resolved或是rejected，程序会死掉，因此首先要处理它：

     ```js
     function resolvePromise(promise2, x, resolve, reject) {
         if(promise2 === x) {
             reject(new TypeError('promise发生了循环引用'))
         }
     }
     ```

   - 当`x`就是一个Promise，那么就执行它，成功即成功，失败即失败。若`x`是一个对象或是函数，再进一步处理它，否则就是一个普通值：

     ```js
     function resolvePromise(promise2, x, resolve, reject) {
         if(promise2 === x) {
             reject(new TypeError('promise发生了循环引用'))
         }
         
         if(x!=null && (typeof x === 'object'||typeof x === 'function')) {
             //可能是个对象或是函数
         }else {
             //否则是个普通值
             resolve(X)
         }
     }
     ```

   - 规范中说明，若是个对象，则尝试将对象上的then方法取出来，此时如果报错，那就将promise2转为失败态。

     ```js
     if(x!=null && (typeof x === 'object'||typeof x === 'function')) {
         //可能是个对象或是函数
         try{
             let then = x.then;//取出then方法引用
             if(typeof then === 'function'){
                 //then是function，那么执行promise
                 then.call(x,(y) => {
                     resolve(y)
                 },(r) => {
                     reject(r)
                 })
             }
         }catch(e) {
             reject(e)
         }
     }else {
         //否则是个普通值
         resolve(X)
     }
     ```

   - 但是还有一种极端的情况，如果Promise对象转为成功态或是失败时传入的还是一个Promise对象，此时应该继续执行，直到最后的Promise执行完。

     ```js
     if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
         //可能是个对象或是函数
         try {
             let then = x.then; 
             if (typeof then === 'function') {
                 let y = then.call(x, (y) => {
                     //递归调用，传入y若是Promise对象，继续循环
                     resolvePromise(promise2, y, resolve, reject);
                 }, (r) => {
                     reject(r);
                 });
             } else {
                 resolve(x);
             }
         } catch (e) {
             reject(e);
         }
     
     } else {
         //是个普通值，最终结束递归
         resolve(x);
     }
     ```

   - 将同步代码变成异步

     ```js
     setTimeout(() => {
         try {
             let x = onFulfilled(value);
             resolvePromise(promise2, x, resolve, reject);
         } catch (e) {
             reject(e);
         }
     },0);
     ```

## 22.理解js异步操作

### js的单线程和事件循环机制

js的单线程意味着，在执行js时只有一个主线程，每个任务必须按顺序执行，如果当前任务执行时间较长就会阻塞接下来的所有任务

为了解决主线程执行导致的阻塞问题，发明了事件循环机制

事件循环机制中，负责执行js脚本的单线程我们称为主线程，在内存中表现为一个执行栈，js只通过主线程执行任务。异步任务被挂起，存储在堆中，当异步任务准备就绪，它对应的事件便进入任务队列。主线程首先执行同步任务，然后查看任务队列中是否有准备就绪的异步任务（或者时间到了的异步任务），调用相应的回调函数执行，直到任务队列为空

### 异步任务

异步任务是指被js引擎放在一边，不进入主线程而进入任务队列的任务

- 网络请求（Ajax）
- 事件触发（onClick）
- 定时函数（setTimeOut，setTimeInterval）

这些异步操作是由浏览器内核呈现引擎进行执行的

### 宏任务与微任务

宏任务：macro task

- 定时器
- Ajax
- 事件绑定
- 回调函数
- nodejs中可以进行异步操作的i/o操作

微任务：micro task

- promise（asyc/await) ： Promise并不是完全的同步，当在Excutor中执行resolve或者reject的时候，此时是异步操作，会先执行then/catch等，当主栈完成后，才会再去调用resolve/reject把存放的方法执行
- process.nextTick （node中实现的api，把当前任务放到主栈最后执行，当主栈执行完，先执行nextTick，再到等待队列中找）
- MutationObserver  （创建并返回一个新的 MutationObserver 它会在指定的DOM发生变化时被调用。）

执行顺序优先级：同步 => 微任务 => 宏任务

![img](https://img-blog.csdnimg.cn/20190316193840698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8yODkwMDMwNw==,size_16,color_FFFFFF,t_70)

## 23.垃圾回收

垃圾回收的基本思路：确定哪个变量不会在使用，然后释放它占用的内存

### 标记清除

当一块内存中的数据能够被访问时，垃圾回收器就认为"该数据能够被获得"。不能够被获得的数据，就会被打上标记，并回收内存空间。这种方式叫作标记---清除算法。

这个算法会设置一个全局对象，并定期地从全局对象开始查找，垃圾回收器会找到所有可以获得与不能获得的数据。

　　工作流程：

　　　（1）垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。

　　　（2）去掉环境中的变量以及被环境中的变量引用的变量的标记。

　　　（3）再被加上标记的会被视为准备删除的变量。

　　　（4）垃圾回收器完成内存清除工作，销毁那些带标记的数据并回收它们所占用的内存空间。

　　注意：在局部作用域中，当函数执行完毕后，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但在全局中，变量什么时候需要自动释放内存空间则很难判断，因此我们在开发时，应尽量避免使用全局变量。如果使用了全局变量，则建议不再使用它时，通过释放变量方式，以确保能够及时回收内存空间。

### 引用计数

跟踪记录每个值被引用的次数。例当变量声明，第一次赋值时记为1，然后当这个变量值改变时，记录为0，将计数为0的回收。

　　工作流程：

　　　（1）声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。

　　　（2）同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.

　　　（3）当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.

　　　（4）当引用次数变成0时，说明没办法访问这个值了。

　　　（5）当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。

### 内存管理

1. 通过const和let关键字提升性能：使用块级作用域，能让垃圾回收程序更早的介入

2. 隐藏类和删除操作：使用同一个构造函数和原型，不使用delete删除属性而使用null

3. 内存泄漏：内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

   常见原因：

   - 意外的全局变量
   - DOM清空时，还存在引用
     - 给DOM对象添加的属性是一个对象的引用
     - 元素引用没有清理
     - 事件的绑定没有移除
   - 定时器中的内存泄漏：定时器setInterval或者setTimeout在不需要使用的时候，没有被clear，导致定时器的回调函数及其内部依赖的变量都不能被回收，这就会造成内存泄漏。
   - 不规范的使用闭包


## 24.Ajax相关

### 实现Ajax请求

```js
function ajax(){
    //创建xhr实例对象
    let xhr = new XMLHTTPRequest()
    //调用open方法准备发送请求
    xhr.open('get','http://www.baidu.com')
    //处理响应
    xhr.onreadystatechange = ()=>{
        //4阶段表示接收完成
        if(xhr.readyState === 4){
            //响应码200-299表示响应成功
            if(xhr.status>=200&&xhr.status<300){
                let string = xhr.requestText
            }
        }
    }
    //发送请求
    xhr.send()
}
```

### GET和POST请求直接的区别

1. get请求回退时是无害的，post会再次提交表单
2. get请求产生的url可以被bookmark，post不可以
3. get请求会主动被浏览器cache，而post不会
4. get请求只能进行url编码，而post支持多种编码
5. get请求参数会被完整的保存在浏览器历史记录里，而post中的参数不会保留
6. get请求在url中传送的参数长度有限，而post没有
7. 对参数的数据类型get请求只接收ASCII码，post没有限制
8. get请求比post更不安全，因为参数直接暴露在url中
9. get参数通过url传递，post放在request body中
10. get产生一个tcp数据包，post产生2个tcp数据包：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。并不是所有浏览器都会在post请求时2次包，例如火狐浏览器

### 跨域问题

1. JSONP：通过使用html标签 `<script> `标签不发生跨域的特点，在服务器链接的参数中加入callback回调函数，通过这个回调函数获取服务端要传来的值，缺点只能实现get一种请求

2. postMessage(data,origin)

   1. 页面和其打开的新窗口的数据传递
   2. 多窗口之间消息传递
   3. 页面与嵌套的iframe消息传递
   4. 上面三个场景的跨域数据传递

3. 跨域资源共享（Cross-Origin Recourse Sharing，CORS）：普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。

4. 代理服务器转发，设置一个与客户端同源的代理服务器作为中间人转发数据

5. webSocket协议跨域：服务器响应后，连接使用http的upgrade头部从http协议切换到webSocket协议，URL使用ws://或wss://（对应http:// 和 https://），创建websocket对象时必须传入一个绝对url 

   ```js
   let socket = new WebSocket('ws://www.google.com/')
   ```

## 25.iframe标签

`<iframe>`标签是一个内联框架，用来在当前HTML页面中**嵌入另一个文档**的，且所有主流浏览器都支持iframe

**基本语法**：`<iframe src = '路径名称'></iframe>`

## 26.http和https

HTTP协议以明文的方式发送内容，不提供任何方式的数据加密，存在安全问题，使用80端口

HTTPs在HTTP下加入SSL（Secure Socket Layer，安全套接字层）/TLS，使用443端口

### HTTPs工作原理（主要是ssl握手阶段）

一共分为4个阶段（A为客户端，B为服务端）：

1. 协商加密算法：A向B发送自己可支持的加密算法，B从中选定算法并告知A
2. 服务器鉴别：B向A发送包含其公钥的数字证书，A使用CA发布的公钥对该证书进行鉴别
3. 会话密钥计算：鉴别完毕后，A产生一个秘密数并使用B的公钥对秘密数加密后发送给B，B再用自己的私钥解密获得该秘密数，二者同时通过协商好的加密算法对秘密数进行加密，获得此次会话的共享密钥
4. 安全数据传输：双方使用会话密钥对发送数据进行加密传输

### HTTP1.0 和 HTTP1.1 的区别

HTTP1.0支持持续连接和流水线方式，在一个TCP连接上可以传送多个HTTP请求和响应。减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

### HTTP1.1和HTTP2.0的区别

1. 使用多路复用技术，做到同一个连接并发处理多个请求
2. 头部数据压缩
3. 服务器推送，服务端推送是一种在客户端请求之前发送数据的机制，可以通过解析html中的依赖,智能的返回所需的其他文件(css或者js等),而不用再发起一次请求.
4. 二进制传输

## 27.XSS和CFRS

### XSS（跨站脚本攻击）

#### 攻击类型

1. DOM类型XSS

   > * 攻击者构造出特殊的URL,其中包含恶意代码
   > * 用户打开带有恶意代码的URL
   >  * 用户浏览器接收到响应后解析执行,前端JS取出URL中的恶意代码并执行
   >  * 恶意代码且与用户数据并发送到攻击者的网站,或者冒充用户行为,调用目标网站接口执行攻击者指定的操作

2. 反射型XSS（非持久型）

   将恶意代码存储到url中

   > * 攻击者构造出特殊的URL,其中包含恶意代码
   > * 用户打开带有恶意代码的URL时,网站服务端**将恶意代码从URL中取出**,拼接在HTML中返回给浏览器
   > * 用户浏览器接收到响应后解析执行,同时混在其中的恶意代码也会被执行
   > * 恶意代码窃取用户数据并发送到攻击者的网站,或者冒充用户的行为,调用目标网站接口执行攻击者指定的操作

3. 存储型XSS（持久型）

   将恶意代码存储到数据库中

   > * 攻击者将恶意代码提交到目标网站的数据库中
   > * 用户打开目标网站时,网站服务器将**恶意代码从数据库取出**: 拼接在HTML中返回给浏览器
   > * 用户浏览器接收到响应后解析执行,混在其中的恶意代码也被执行
   > * 恶意代码窃取用户数据并发送到攻击者的网站,或者冒充用户的行为,调用目标网站接口执行攻击者指定的操作

#### 解决方案

1. httpOnly：在cookie中设置httpOnly属性，使得js脚本无法获得cookie信息
2. 输入过滤：将输入的敏感字符进行过滤
3. 转义HTML，对不同部分进行不同编码

### CSRF（跨域请求伪造）

  - 攻击者盗用了你的身份,以你的名义发送恶意请求
  - 对于服务器来说这个请求完全是合法的,但是时却完成攻击者所期望的一个动作: 以你的名义发送邮件、发消息、添加系统管理员、甚至于转账、购买商品等

#### 防范措施

1. Get 请求不对数据进行修改
2. 不让第三方网站访问到用户Cookie
3. 阻止第三方网站请求接口
4. 请求时附带验证信息，如验证码或Token(这种情况下会发送预检请求)

## 28.常见状态码

- 1xx 信息性状态码，表示接收的请求正在处理
- 100（请求以被部分处理）、101（切换协议）
  2xx 成功状态码，表示请求正常处理完毕

- 200（请求成功）、204（请求处理成功，但没有内容返回）、206（返回指定范围的内容）
  3xx 重定向状态码，表示需要进行附加操作以完成请求

- 301（永久重定向）、302（临时重定向）、303（临时重定向，但要求使用GET方法）、304（请求资源未更改，直接使用缓存）
  4xx 客户端错误状态码，表示服务器无法处理请求

- 400（请求出错）、401（未授权）、403（被服务器拒绝访问）、404（服务器上没有请求的资源）
  5xx 服务器错误状态码，表示服务器请求出错

- 500（服务器内部错误）、503（服务器暂时无法处理请求）

## 29.节流防抖

### 防抖

#### 定义

在事件被触发n秒后再执行回调函数，如果在这n秒内又被触发，则重新计时。

#### 应用场景

(1) 用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询ajax请求，这样可以有效减少请求次数，节约请求资源；

(2) window的resize、scroll事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次；

#### 代码实现

1.每一次事件被触发，都会清除当前的 timer 然后重新设置超时调用，即重新计时。 这就会导致每一次高频事件都会取消前一次的超时调用，导致事件处理程序不能被触发；

2.只有当高频事件停止，最后一次事件触发的超时调用才能在delay时间后执行；

```js
function debounce(fn,delay){
    if(typeof fn !== 'function'){
        throw new TypeError('fn not a function')
    }
    let timer
    return function(){
        // 获取函数的作用域和变量
        var _this = this
        var args = arguments
        if(timer){
            clearTimeOut(timer)
        }
        timer = setTimeOut(function(){
            fn.apply(_this,args)
        },delay)
    }
}
```

### 节流

#### 定义

规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。

#### 应用场景

(1)鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次；

(2)在页面的无限加载场景下，需要用户在滚动页面时，每隔一段时间发一次 ajax 请求，而不是在用户停下滚动页面操作时才去请求数据；

(3)监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断；

#### 代码实现

(1)当代码中存在正在运行的timer则直接返回，若不存在就设置一个新的定时器

```js
function throttle(fn,delay){
    let timer
    return function(){
        var _this = this
        var args = arguments
        if(timer){
            return
        }
        timer = setTimeOut(function(){
            fn.apply(_this,args)
            timer = null
        },delay)
    }
}
```

### 总结

总结下防抖和节流的区别：

-- 效果：

函数防抖是某一段时间内只执行一次；而函数节流是间隔时间执行，不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。

-- 原理：

防抖是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，都会清除当前的 timer 然后重新设置超时调用，即重新计时。这样一来，只有最后一次操作能被触发。

节流是通过判断是否到达一定时间来触发函数，若没到规定时间则使用计时器延后，而下一次事件则会重新设定计时器。

## 30.重绘、重排和回流

![img](https://img-blog.csdnimg.cn/2019052111030991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E0MTk0MTk=,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/2019052111032346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E0MTk0MTk=,size_16,color_FFFFFF,t_70)

渲染引擎会解析HTML文档来构建DOM树，与此同时，渲染引擎也会用CSS解析器解析CSS文档构建CSSOM树。接下来，DOM树和CSSOM树关联起来构成渲染树（RenderTree），这一过程称为Attachment。然后浏览器按照渲染树进行布局（Layout），最后一步通过绘制显示出整个页面。


当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

**注意：回流必将引起重绘，而重绘不一定会引起回流。回流会导致渲染树需要重新计算，开销比重绘大，所以我们要尽量避免回流的产生**，影响页面布局的改变会产生回流，只是影响元素外观背景不影响页面布局的改变会产生重绘

## 31.flex布局

flex是flexible box的缩写，意为“弹性布局“

采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。

### 容器属性（重点）

1. `flex-direction`：

   - `row`（默认值）：主轴为水平方向，起点在左端。
   - `row-reverse`：主轴为水平方向，起点在右端。
   - `column`：主轴为垂直方向，起点在上沿。
   - `column-reverse`：主轴为垂直方向，起点在下沿。

2. `flex-wrap`:项目都排在一条线（又称"轴线"）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行。

   - `nowrap`(默认值)：不换行
   - `wrap`：换行，第一行在上方
   - `wrap-reverse`：换行，第一行在下方

3. `flex-flow`：`flex-flow` 属性是 `flex-direction` 属性和 `flex-wrap` 属性的简写形式，默认值为 `row nowrap`

4. `justify-content`：定义了项目在主轴上的对齐方式（水平）

   - `flex-start`：左对齐
   - `flex-end`：右对齐
   - `center`：居中对齐
   - `space-between`：两端对齐，项目中间间隔相等
   - `space-around`：项目两侧间隔相等，依次项目之间的间隔是项目与容器间隔的一倍

   <img src="C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220330103714772.png" alt="image-20220330103714772" style="zoom: 67%;" />

5. `align-items`：定义项目在交叉轴上如何对齐（垂直方向）

   - `flex-start`：上对齐
   - `flex-end`：下对齐
   - `center`：居中对齐
   - `baseline`：项目的第一行文字的基线对齐。
   - `stretch`（默认）：如果项目未设置高度或设为auto，将占满整个容器的高度。

   <img src="C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220330104012690.png" alt="image-20220330104012690" style="zoom: 67%;" />

6. `align-content`：定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用

   - `flex-start`：与交叉轴的起点对齐。
   - `flex-end`：与交叉轴的终点对齐。
   - `center`：与交叉轴的中点对齐。
   - `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。
   - `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
   - `stretch`（默认值）：轴线占满整个交叉轴。

   <img src="C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220330104136105.png" alt="image-20220330104136105" style="zoom: 67%;" />

### 项目属性

1. `order`：属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
2. `flex-grow`：属性定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。
3. `flex-shrink`：属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
4. `flex-basis`：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。
5. `flex`：`flex-grow`,`flex-shrink`和`flex-basis`的简写，默认值为0 1 auto
6. `align-self`：属性允许单个项目有与其他项目不一样的对齐方式

## 32.继承实现

1. 原型链继承：让新实例的原型等于父类的实例

   特点：新实例可以继承构造函数的属性，父类构造函数的属性以及父类原型的属性和方法

   缺点：1.新实例无法向父类构造器传参

   ​			2.所有新实例都会共享父类实例的属性（一个实例修改了原型的属性，所有实例的原型属性都会被修改）

2. 借用构造函数继承：用.call()和.apply()将父类构造函数引入子类函数

   特点：1.只继承了父类构造函数的属性和方法，没有继承父类原型的属性

   ​			2.解决了原型链继承的缺点

   缺点：1.只能继承父类构造函数的属性，不能访问父类原型上的方法

   ​			2.必须在构造函数中定义方法，无法实现构造函数的重用

3. 组合继承：组合原型链继承和借用构造函数，使用原型链继承构造函数原型属性和方法，通过借用构造函数继承实例属性

   特点：1.可以继承父类原型上的属性，可以传参，可复用。

   缺点：两次调用了父类构造函数

4. 原型式继承：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。

   缺点：1.所有实例都会继承父类原型上的方法属性

   ​			2.无法实现复用

5. 寄生式继承：给原型式继承再加一层函数生成实例

6. 寄生式组合继承：通过借用构造函数来继承属性，通过原型链形式来继承方法，会解决2次调用父类函数以及复用率的问题。

## 33.类数组转换为数组的方法

1. `Array.prototype.slice.call(arraylike)`：slice为Array的原型方法，返回一个数组，call只能在方法后调用，将call的环境设为arraylike就好像arraylike也有了数组的方法
2. `Array.from()`
3. 扩展运算符[...arguments]

## 34.什么是前端工程化

前端工程化是使用软件工程的方法来解决前端的开发流程中模块化、组件化、规范化、自动化的问题，其主要目的*为了提高效率和降低成本。*

### 为什么要前端工程化

- 扩展javascript、html、css本身的语言能力：使用ts，css预处理器
- 进行高效的多人协作：模块化（模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载）
- 解决功能复用和变更问题：组件化（对UI（用户界面）的拆分。从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件）
- 保证项目的规范性
- 实现重复的劳动简单化：自动化工具（gulp、webpack、vite）

## 35.模块化（Common JS、AMD、UMD、ES6、CMD）

Common JS：主要运行于服务器端，一个文件就是一个模块，Nodejs为主要实践者。主要命令：`require` 用于输入其他模块，`module.exports` 用于规范模块的对外接口。采用同步加载模块，而加载的文件资源大多数在本地服务器，所以执行速度或时间没问题

1. CommonJS 模块中 require 引入模块的位置不同会对输出结果产生影响，并且会生成值的拷贝
2. CommonJS 模块重复引入的模块并不会重复执行，再次获取模块只会获得之前获取到的模块的缓存

```js
// 模块 a.js
const name = 'qiufeng'

module.exports = {
    name,
    github: 'https://github.com/hua1995116'
}
// 模块 b.js
// 引用核心模块或者第三方包模块，不需要写完整路径
const path = require('path');
// 引用自定义模块可以省略.js
const { name, github } = require('./a');

console.log(name, github, path.basename(github));
// 输出 qiufeng https://github.com/hua1995116 hua1995116
```

AMD：异步模块定义，采用异步方式加载模块，模块的加载不影响它后面的语句，所有需要模块的语句都定义在一个回调函数里，等到模块加载完毕以后再执行回调函数，RequireJs为主要实践者。主要命令：`require`用于输入其他模块，`define`用于定义模块，`return`用于规范模块的对外接口，`define.amd`是一个属性表明函数遵循AMD规范

```js
// model1.js
define(function () {
    console.log('model1 entry');
    return {
        getHello: function () {
            return 'model1';
        }
    };
});
// main.js
define(function (require) {
    var model1 = require('./model1');
    console.log(model1.getHello());
    //var model2 = require('./model2');
    //console.log(model2.getHello());
});
<script src="https://cdn.bootcss.com/require.js/2.3.6/require.min.js"></script>
<script>
    requirejs(['main']);
</script>
```

CMD：通用模块定义，主要在浏览器中运行，一个文件就是一个模块，Seajs为主要实践者，与AMD类似

```js
// model1.js
define(function (require, exports, module) {
    console.log('model1 entry');
    exports.getHello = function () {
        return 'model1';
    }
});
// main.js
define(function(require, exports, module) {
    var model1 = require('./model1'); //在需要时申明
    console.log(model1.getHello());
    //var model2 = require('./model2'); //在需要时申明
    //console.log(model2.getHello());
});
<script src="https://cdn.bootcss.com/seajs/3.0.3/sea.js"></script>
<script>
    seajs.use('./main.js')
</script>
```

UMD：通用模块定义，解决Commonjs模块和AMD模块代码不能通用的问题

ES Module：是JavaScript官方的标准化模块系统

- 它因为是标准，所以未来很多浏览器会支持，可以很方便的在浏览器中使用。(浏览器默认加载不能省略.js)
- 它同时兼容在node环境下运行。
- 模块的导入导出，通过`import`和`export`来确定。 可以和Commonjs模块混合使用。
- ES modules 输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝
- ES modules 模块编译时执行，而 CommonJS 模块总是在运行时加载

## 36.target和currentTarget的区别

本质区别是：

- event.target是指获取事件的目标
- event.currentTarget是指其事件处理程序当前正在处理事件的那个元素

## 37.vue中key的问题

1. 虚拟DOM中key的作用：

   key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

2. 对比规则：

   - 旧虚拟DOM中找到了与新虚拟DOM相同的key：
     - 若虚拟DOM中内容没变, 直接使用之前的真实DOM！
     - 若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。
   - 旧虚拟DOM中未找到与新虚拟DOM相同的key
     - 创建新的真实DOM，随后渲染到到页面。

3. 用index作为key可能会引发的问题：

   - 若对数据进行：逆序添加、逆序删除等破坏顺序操作:

     会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。

   - 如果结构中还包含输入类的DOM：

     会产生错误DOM更新 ==> 界面有问题。
