# 项目笔记

## 需求分析

- 第一，要有数据的展示，这个是所有网站共有的特性，而且最好是有多级复杂数据的展示
- 第二，要有数据的创建，这就是表单的作用，有展示自然要有创建。在创建中，我们会发散很多问题，比如数据的验证怎样做，文件的上传如何处理，创建和编辑怎样共享单个页面等等。
- 第三，要有组件的抽象，vue 是组件的世界，组件是最重要的一环，编写组件是最基本的能力，对于一些常用的功能，我们需要高可用性和可定制性的组件，也就是说我们在整个项目中一般不会用到第三方组件，比如 element，都是从零开始，而且会循序渐进，不断抽象。甚至行成自己的一套小组件库。
- 第四，整体状态数据结构的设计和实现，SPA 一般使用状态工具管理整理状态，并且给多个路由使用，在 vue 中，我们使用 vuex，一个项目的整体数据结构的复杂程度就代表了这个能力的高低，最好是要有多层次的数据结构，相互依赖的关系，还要将数据的获取，结构设计，缓存进行一系列的考量。
- 第五，权限管理和控制，一个项目需要有用户权限的实现，不仅仅是后端，前端作为一个整体的 SPA 的项目，权限控制也尤为重要，我们需要有权限的获取，权限的持久化，权限的更新，那个路由可访问，哪个需要权限才可以访问。发送异步请求的全局 token 注入，全局拦截，全局信息提示等等和权限相关的内容。
- 第六，真实的后端API，和后端的交互是整个项目的最重要一环。一些同学在开发项目的时候会使用 mock server，但是由于后端的数据结构常常和最初的文档设计背道而驰，造成最后项目需要再次回炉修改。

## 整个项目结构

1. 导航栏
2. 专栏列表
3. 专栏页面
4. 文章列表
5. 文章详情页
6. 创建编辑数据，表单部分，创建文章
7. 登陆注册
8. 编辑个人资料
9. 编辑专栏信息
10. 权限系统

## 完成组件

1. Drop-down 下拉菜单
2. message 组件和 modal 组件 提供信息提示
3. 上传组件
4. form组件

## 文件结构与代码规范

### 脚手架配置

![image-20220304095302676](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220304095302676.png)

### 文件结构

![image-20220304095512585](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220304095512585.png)

### 安装Bootstrap

使用Bootstrap v5.0.0 以上，我将Bootstrap安装在了项目目录的根目录下，也就是./web test

`npm install bootstrap --save`

## 开发流程

1. 将 UI 划分出组件的层级
2. 创建应用的静态版本
   - Header.vue
   - intro.vue
   - ColumnList.vue
   - LoadMore.vue

## ColumnList组件

```vue
<ColumnList list = {columns} />
<script>
	//list属性应该是一个数组,数组里面是含有各种属性的一个对象object
	interface ColumnProps{
	id:number;
	avatar:string;//头图标识
	discription:string;//专栏简介
}
</script>
```

1. 创建组件

   ```vue
   <template>
     <ul>
       <li v-for="column in list" :key="column.id">
         <img :src="column.avatar" :alt="column.title">
         <h5>{{column.title}}</h5>
         <p>{{column.description}}</p>
         <a href="#">进入专栏</a>
       </li>
     </ul>
   </template>
   
   <script lang="ts">
   import { defineComponent, PropType } from 'vue'
   export interface ColumnProps {
     id: number;
     title: string;
     avatar: string;
     description: string;
   }
   export default defineComponent({
     name: 'ColumnList',
     props: {
       list: {
         //这里特别有一点，我们现在的 Array 是没有类型的，只是一个数组，我们希望它是一个 ColomnProps 的数组，那么我们是否可以使用了类型断言直接写成 ColomnProps[]，显然是不行的 ，因为 Array 是一个数组的构造函数不是类型，我们可以使用 PropType 这个方法，它接受一个泛型，讲 Array 构造函数返回传入的泛型类型。
         type: Array as PropType<ColumnProps[]>,
         required: true
       }
     }
   })
   </script>
   ```

2. 引入bootstrap

   ```js
   import 'bootstrap/dist/css/bootstrap.min.css'
   ```

3. 使用bootstrap

   ```html
   <div class="row">
       <div v-for="column in columnList" :key="column.id" class="col-4 mb-4">
         <div class="card h-100 shadow-sm">
           <div class="card-body text-center">
             <img  :src="column.avatar" :alt="column.title" class="rounded-circle border border-light w-25 my-3" >
             <h5 class="card-title">{{column.title}}</h5>
             <p class="card-text text-left">{{column.description}}</p>
             <a href="#" class="btn btn-outline-primary">进入专栏</a>
           </div>
         </div>
       </div>
     </div>
   ```

4. 设置默认的 avator 图片

   ```js
   //注意这里循环的应该是我们新的计算属性返回的 columnList ，而不是原来的list  
   setup(props) {
       const columnList = computed(() => {
         return props.list.map(column => {
           if (!column.avatar) {
             column.avatar = require('@/assets/column.jpg')
           }
           return column
         })
       })
       return {
         columnList
       }
     }
   
   ```

## GlobalHeader组件

```vue
<GlobalHeader :user = "currentUser" />
<script>
	//list属性应该是一个数组,数组里面是含有各种属性的一个对象object
	interface UserProps{
		isLogin:boolean;
        name?:string;
        id?:number;
	}
</script>
```

1. 创建组件，引入bootstrap

   ```vue
   <template>
       <nav class="navbar navbar-dark bg-primary justify-content-between mb-4 px-4">
       <a class="navbar-brand" href="#">者也专栏</a>
       <ul v-if="!user.isLogin" class="list-inline mb-0">
         <li class="list-inline-item"><a href="#" class="btn btn-outline-light my-2">登陆</a></li>
         <li class="list-inline-item"><a href="#" class="btn btn-outline-light my-2">注册</a></li>
       </ul>
       <ul v-else class="list-inline mb-0">
         <li class="list-inline-item">
           <drop-down :title="`你好 ${user.name}`"></drop-down>
         </li>
       </ul>
     </nav>
   </template>
   
   <script lang="ts">
   import { defineComponent, PropType } from 'vue'
   import DropDown from './DropDown.vue'
   // 定义用户数据类型
   export interface UserProps {
       isLogin: boolean;
       name?: string;
       id?: number;
   }
   export default defineComponent({
     name: 'GlobalHeader',
     components: {
       DropDown
     },
     props: {
       user: {
         type: Object as PropType<UserProps>,
         required: true
       }
     }
   })
   
   </script>
   
   <style>
   
   </style>
   
   ```

2. 将组件引入App.vue

   ```js
   import GlobalHeader, { UserProps } from './components/GlobalHeader.vue'
   //创建测试用户
   const currentUser: UserProps = {
     isLogin: true,
     name: 'viking'
   }
   //响应式数据
   export default defineComponent({
     name: 'App',
     components: {
       ...,
       GlobalHeader
     },
     setup () {
       return {
         ...,
         currentUser
       }
     }
   })
   ```

## DropDown组件

### 基本功能

```vue
<template>
<div class="dropdown">
  <a href="#" class="btn btn-outline-light my-2 dropdown-toggle" @click.prevent="toggleOpen">
    {{title}}
  </a>
  <ul class="dropdown-menu" :style="{display: 'block'}" v-if="isOpen">
    <li class="dropdown-item">
      <a href="#">新建文章</a>
    </li>
    <li class="dropdown-item">
      <a href="#">编辑资料</a>
    </li>
  </ul>
</div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'
export default defineComponent({
  name: 'Dropdown',
  props: {
    title: {
      type: String,
      required: true
    }
  },
  setup() {
    const isOpen = ref(false)
    //绑定点击事件，设置下拉菜单显示
    const toggleOpen = () => {
      isOpen.value = !isOpen.value
    }
    return {
      isOpen,
      toggleOpen
    }
  }
})
</script>
```

### 添加DropDownItem

```html
//第一种形式
const dropdownItems = [
    {'text':'option one'},
    {'text':'option two'}
]
<drop-down :title="" :items="dropdownItems"/>
//第二种形式	
<drop-down :title="">
    <dropdown-item>
        option one
    </dropdown-item>
    <dropdown-item disabled>
        option two
    </dropdown-item>
</drop-down>
```

1. 创建组件

   ```vue
   <template>
   <!-- 添加一个动态的class -->
     <li class="dropdown-option"
       :class="{'is-disabled': disabled}"
     >
   <!-- 添加一个插槽 -->
         <slot></slot>
     </li>
   </template>
   
   <script lang="ts">
   import { defineComponent } from 'vue'
   export default defineComponent({
     name: 'DropdownItem',
     props: {
         // 判断组件是否禁用
       disabled: {
         type: Boolean,
         default: false
       }
     }
   })
   </script>
   
   <style>
   .dropdown-option.is-disabled * {
     color: #6c757d;
     pointer-events: none;
     background-color: transparent;
   }
   </style>
   
   ```

2. 将组件添加到GlobalHeader

   ```vue
   <template>
   	<ul v-else class="list-inline mb-0">
         <li class="list-inline-item">
           <drop-down :title="`你好 ${user.name}`">
             <dropdown-item><a href="#" class="dropdown-item">新建文章</a></dropdown-item>
             <dropdown-item disabled><a href="#" class="dropdown-item">编辑资料</a></dropdown-item>
             <dropdown-item><a href="#" class="dropdown-item">退出登录</a></dropdown-item>
           </drop-down>
         </li>
       </ul>
   </template>
   ```

###  Dropdown 组件点击外部区域自动隐藏

分析：

- 在mounted 时候添加click事件，在unmounted 的时候删除事件
- 拿到DropDown 的DOM元素从而判断，点击的内容是否被这个元素包含

1. 给模板添加ref属性，使vue能拿到DropDown的DOM元素

   ```html
   <div class="dropdown" ref="dropdownRef">
   ```

2. 实现代码逻辑

   ```js
   const dropdownRef = ref<null | HTMLElement>(null)
   const handler = (e: MouseEvent) => {
       if (dropdownRef.value) {
        // 判断鼠标是否在dropdown内部且dropdown打开   
           if (!dropdownRef.value.contains(e.target as HTMLElement) && isOpen.value) {
               isOpen.value = false
           }
       }
   }
   onMounted(() => {
       document.addEventListener('click', handler)
   })
   onUnmounted(() => {
       document.removeEventListener('click', handler)
   })
   return {
       isOpen,
       toggleOpen,
       // 返回和 ref 同名的响应式对象，就可以拿到对应的 dom 节点
       dropdownRef
   }
   ```

### useClickOutside 第一个自定义函数

```ts
import { ref, onMounted, onUnmounted, Ref } from 'vue'
// 确定传入的参数，不仅要是一个dom节点，还得是一个响应式对象，大写的Ref代表的是一个类
const useClickOutside = (elementRef: Ref<null | HTMLElement>) => {
  // 创建一个变量，代表是否点击到元素外
  const isClickOutside = ref(false)
  // 回调函数
  const handler = (e: MouseEvent) => {
    if (elementRef.value) {
      if (elementRef.value.contains(e.target as HTMLElement)) {
        isClickOutside.value = false
      } else {
        isClickOutside.value = true
      }
    }
  }
  // 挂载后开始监听事件
  onMounted(() => {
    document.addEventListener('click', handler)
  })
   // 卸载时删除事件
  onUnmounted(() => {
    document.removeEventListener('click', handler)
  })
  return isClickOutside
}

export default useClickOutside

```

```js
import useClickOutside from '../hooks/useClickOutside'
...
const isClickOutside = useClickOutside(dropdownRef)
//使用时注意用watch监视isClickOutside的变化，否则只会被渲染一次
    watch(isClickOutside, () => {
      if (isOpen.value && isClickOutside.value) {
        isOpen.value = false
      }
    })
...
```

## 自定义form组件

### 需求分析

![image-20220305104224940](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220305104224940.png)

### 简单实现

1. 从bootstrap 中引入表单

   ```html
   <form>
     <div class="mb-3">
       <label for="exampleInputEmail1" class="form-label">Email address</label>
       <input type="email" class="form-control" id="exampleInputEmail1" aria-describedby="emailHelp">
       <div id="emailHelp" class="form-text">We'll never share your email with anyone else.</div>
     </div>
     <div class="mb-3">
       <label for="exampleInputPassword1" class="form-label">Password</label>
       <input type="password" class="form-control" id="exampleInputPassword1">
     </div>
     <div class="mb-3 form-check">
       <input type="checkbox" class="form-check-input" id="exampleCheck1">
       <label class="form-check-label" for="exampleCheck1">Check me out</label>
     </div>
     <button type="submit" class="btn btn-primary">Submit</button>
   </form>
   ```

2. 编写验证逻辑，现在有2个规则，不能为空和需要邮件地址

   ```js
   //邮件格式正则表达式
   const emailReg = /^\w+@[a-zA-Z0-9]{2,10}(?:\.[a-z]{2,4}){1,3}$/
   
   const emailRef = reactive({
     val: '',
     error: false,
     message: ''
   })
   const validateEmail = () => {
       //判断是否为空
     if (emailRef.val.trim() === '') {
       emailRef.error = true
       emailRef.message = 'can not be empty'
         //判断是否是邮件格式
     } else if (!emailReg.test(emailRef.val)) {
       emailRef.error = true
       emailRef.message = 'should be valid email'
     }
   }
   
   return {
     emailRef,
     validateEmail
   }
   ```

### 抽象验证规则

组件逻辑：

```vue
<validate-input :rule=""/>

interface RuleProp { 
	type: 'required' | 'email' | 'range' | ...;
	message: string;
}

export type RulesProp = RuleProp[]
```

1. 编写组件

   ```vue
   <template>
     <div class="validate-input-container pb-3">
         <!-- 添加可选类名，根据inputRef.error判断，当有错误时添加类名 -->
       <input type="text"
         class="form-control"
         :class="{'is-invalid': inputRef.error}"
         v-model="inputRef.val"
         @blur="validateInput"
       >
       <!-- 当有错误时，打开提示 -->
       <span v-if="inputRef.error" class="invalid-feedback">{{inputRef.message}}</span>
     </div>
   </template>
   
   <script lang="ts">
   import { defineComponent, reactive, PropType } from 'vue'
   const emailReg = /^\w+@[a-zA-Z0-9]{2,10}(?:\.[a-z]{2,4}){1,3}$/
   //可扩展规则，引用时规则需要满足以下多项
   interface RuleProp {
       type: 'required' | 'email';
       message: string
   }
   export type RuleProps = RuleProp[]
   export default defineComponent({
     props: {
       //一个类型为RuleProps的数组
       rules: Array as PropType<RuleProps>
     },
     setup (props) {
       const inputRef = reactive({
         val: '',
         error: false,
         message: ''
       })
       const validateInput = () => {
         if (props.rules) {
           //   监测rules里的每一项规则是否满足，只要有一项不满足立刻结束判断返回false
           const allPassed = props.rules.every(rule => {
             let passed = true
             inputRef.message = rule.message
               // 判断规则的类型
             switch (rule.type) {
               //   判断是否为空
               case 'required':
                 passed = (inputRef.val.trim() !== '')
                 break
               case 'email':
               // 判断是否满足邮件格式
                 passed = emailReg.test(inputRef.val)
                 break
               default:
                 break
             }
             return passed
           })
           inputRef.error = !allPassed
         }
       }
       return {
         inputRef,
         validateInput
       }
     }
   })
   </script>
   ```
   
2. 使用

   ```html
   <div class="mb-3">
     <label class="form-label">邮箱地址</label>
     <validate-input :rules="emailRules"></validate-input>
   </div>
   ```

   ```js
   const emailRules: RulesProp = [
     { type: 'required', message: '电子邮箱地址不能为空' },
     { type: 'email', message: '请输入正确的电子邮箱格式' }
   ]
   ```

### 支持 v-model

自定义组件的v-model实际上完成的是：

自定义组件中定义一个变量接收输入，输入时触发update事件，将输入内容发送给父组件，父组件的modelValue更新

```html
<!--设定一个model-value的属性，再完成赋值 -->
<custom-input
    :model-value="searchText"
    @update:model-value="searchText=$event"
              ></custom-input>
```



```html
//vue2 原生组件
<input v-model="val">
<input :value="val" @input="val = $event.target.value">

//vue2 自定义组件
<my-component v-model="val" />
<my-component :value="val" @input="val = arguments[0]" />

//特殊的表单元素
<input type="checkbox" :checked = 'val' @change=''>

//vue3 自定义组件
<my-component v-model="foo" />
h(Comp, {
	modelValue: foo,
	'onUpdate:modelvalue': value => (foo = value)
})
<my-component :value = 'foo' @input = ''></my-component>
```

源码：

```vue
<template>
  <div class="validate-input-container pb-3">
    <input type="text"
      class="form-control"
      :class="{'is-invalid': inputRef.error}"
      :value="inputRef.val"
      @blur="validateInput"
      @input="updateValue"
    >
    <span v-if="inputRef.error" class="invalid-feedback">{{inputRef.message}}</span>
  </div>
</template>
<script lang="ts">
  props: {
    rules: Array as PropType<RulesProp>,
    //在props中添加modelValue的属性
    modelValue: String
  },
  const inputRef = reactive({
    //inputRef的值为初始化的值或空
    val: props.modelValue || '',
    error: false,
    message: ''
  })
  //绑定输入事件
  const updateValue = (e: KeyboardEvent) => {
    const targetValue = (e.target as HTMLInputElement).value
    inputRef.val = targetValue
    //触发绑定事件并将值返回给父组件
    context.emit('update:modelValue', targetValue)
  }

</script>
```

### 使用$attrs支持默认属性

#### 非 Prop 的 Attribute

一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 [props](https://v3.cn.vuejs.org/guide/component-props.html) 或 [emits](https://v3.cn.vuejs.org/guide/component-custom-events.html#定义自定义事件) 定义的 attribute。这些attribute会被添加到根元素上，用props接收后将无法传递到下一组件

- 如果给组件传递的数据，**组件不使用props接收，那么这些数据将作为组件的HTML元素的特性，这些特性绑定在组件的HTML根元素上**

- `inheritAttrs: false`的含义是**不希望本组件的根元素继承父组件的attribute**，同时父组件传过来的属性（没有被子组件的props接收的属性），也不会显示在子组件的dom元素上，**但是在组件里可以通过其$attrs可以获取到没有使用的注册属性**, `inheritAttrs: false`是不会影响 style 和 class 的绑定

```vue
<body>
	<div id="app">
		<father :v1="'value1'" :v2="'value2'" :v3="'value3'"></father>
	</div>
</body>

<script>
	Vue.component('father', {
  		inheritAttrs: false,
  		props: ['v1'],
        // 只接收了v1，剩下的传递给son组件
  		template: `
		  	<div>
				<p>v1 is {{v1}}</p>
				<son v-bind='$attrs'></son>
			</div>
		  `
	})

	Vue.component('son',{
		props:['v2'],
        // 接收了v2，剩下的继续传递
		template:"<div ><p>v2 is {{v2}}</p><grandSon v-bind='$attrs'></grandSon></div>"
	})

	Vue.component('grandSon',{
		props:['v3'],
		template:"<p>v3 is {{v3}}</p>"
	})

	var vm = new Vue({
		el:'#app',
		data:{
		},
	})
</script>
```



#### 禁用Attribute继承

如果不希望组件的根元素继承 attribute，可以在组件的选项中设置 `inheritAttrs: false`。

防止外部传来的值成为组件html元素的属性值

```js
app.component('date-picker', {
  inheritAttrs: false,
  props:[...]
  template: `
    <div class="date-picker">
      <input type="datetime-local" v-bind="$attrs" />
    </div>
  `
})
```

#### 使用$attrs

“**透传 attribute**”是传递给组件的 attribute 或者 `v-on` 事件监听器，但并没有显式地声明在所接收组件的 [props](https://staging-cn.vuejs.org/guide/components/props.html) 或 [emits](https://staging-cn.vuejs.org/guide/components/events.html#defining-custom-events) 上。最常见的例子就是 `class`、`style` 和 `id`。

给子组件需要设置attribute的元素上绑定 $attrs ，获得父组件设置的type等属性值

```html
<input
      class="form-control"
      :class="{'is-invalid': inputRef.error}"
      :value="inputRef.val"
      @blur="validateInput"
      @input="updateValue"
      v-bind="$attrs"
    >
<!-- 获取父组件所有除了props和emit以外的属性 -->
```

### Validate-Form组件

#### 需求分析

![image-20220305160959738](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220305160959738.png)

#### 实现步骤

1. 创建ValidateForm组件

   ```vue
   <template>
     <form class="validate-form-container">
         <slot></slot>
         <!-- 点击按钮触发submitForm函数，函数中触发自定义事件"form-submit" -->
         <div class="submit-area" @click.prevent="submitForm">
             <!-- 使用具名插槽，可在父组件更改指定元素部分 -->
             <slot name="submit">
                 <!-- 点击按钮发送事件 -->
               <button type="submit" class="btn btn-primary">提交</button>
             </slot>
         </div>
     </form>
   </template>
   
   <script>
   import { defineComponent } from 'vue'
   export default defineComponent({
     
   })
   </script>
   ```

2. 实现点击触发自定义事件

   ```js
   export default defineComponent({
     emits: ['form-submit'],
     setup (props, context) {
       const submitForm = () => {
          //setup()中没有this，使用context.emit 代替this.$emit
         context.emit('form-submit', true)
       }
       return {
         submitForm
       }
     }
   })
   ```
   
3. App.vue中定义自定义事件，接收子组件发送的参数

   ```vue
   <template>
     <form-component @form-submit="onFormSubmit">
         <div class="mb-3">
           <label class="form-label">邮箱地址</label>
           <input-component :rules="emailRules" v-model="emailVal" type="text" placeholder="请输入邮箱地址"></input-component>
           <label class="form-label">密码</label>
           <input-component :rules="passwordRules" v-model="passwordVal" type="password" placeholder="请输入密码"></input-component>
         </div>
         <template #submit>
           <span class="btn btn-danger">提交</span>
         </template>
       </form-component>
   </template>
   
   <script>
   import { defineComponent } from 'vue'
   export default defineComponent({
     ...
       const onFormSubmit = function(result: boolean){
       // 处理逻辑
   }
   })
   </script>
   ```

### 父子组件通信（valideform中实现valideinput的验证）

要想在父组件中访问子组件的方法，就必须拿到这个方法并且调用

方法一：通过在组件中设置ref属性，拿到组件实例，获取组件内部数据，但由于组件内部是<slot>无法获取<slot>内部实例，只可一个一个子组件获取

```vue
<validate-input :rules="emailRules" v-model="emailVal" type="text" placeholder="请输入邮箱地址" ref="inputRef"></validate-input>
<script>
setup () {
    const inputRef = ref()
    const onFormSubmit = (result: boolean) => {
      //inputRef的value是一个Proxy对象，可访问其中的属性方法
      console.log(inputRef.value.validateInput())
    }
    return {
      onFormSubmit,
      inputRef
    }
  }
</script>
```

方法二：通过添加事件监听器，在父组件中创建一个事件监听器 `this.$on("item-created")`，设置一个数组一开始设置为空，在子组件中设置一个父组件触发item-created事件时，返回想要的函数 `this.$parent.$emit("item-created",validateInput)`，父组件收到子组件传来的 validateInput 后回调函数 `(func) => { validateFuncArr.push(func)}`，每当初始化表单时，父组件都能获取想要的子组件的方法，但是vue3中$on api 已被废除

- 通过 `$on(eventName, eventHandler)` 侦听一个事件
- 通过 `$once(eventName, eventHandler)` 一次性侦听一个事件
- 通过 `$off(eventName, eventHandler)` 停止侦听一个事件

```js
//子组件
this.$parent.$emit("item-created",validateInput)

//父组件
const ValidateFuncArr = []
this.$on("item-created",(func) => {
	ValidateFuncArr.push(func)
})
```

方法三：**使用外部库mitt**

1. 引入外部库，使用管理员模式的cmd进入工作区 `npm install --save mitt `

2. 在父组件 ValidateForm 中引入mitt，并创建一个mitt实例对象，在父组件中使用on方法添加自定义事件，在子组件中在onMounted生命周期函数中触发自定义事件，并向父组件发送数据

   ```ts
   //validateform
   import mitt from 'mitt'
   //创建mitt实例对象
   export const emitt = mitt()
   export default defineComponent({
       name: 'ValidateForm',
       setup(){
           const callback = (test: string) => {
               console.log(test)
           }
           emitt.on('form-item-created',callback)
           onUnmounted(() => {
               emitt.off('form-item-created',callback)
           })
       }
   })
   
   //ValidateInput
   import { emitt } from './ValidateForm.vue'
   ...
   onMounted({
       emitt.emit('form-item-created',inputRef.val)
   })
   ```

3. 注意新版本的mitt错误解决方法

   ```ts
   // 第一步 定义一个 events 类型
   // 这个定义是让事件和对应的 callback 一一对应
   type Events = {
       'form-item-created': string
   }
   // 第二步 实例化 mitt 的时候，作为泛型传递进去
   export const emitter = mitt<Events>()
   
   // 解释：这个 string 和 callback 里面的参数是对应的，callback 是这样的
   const callback = (test: string) => {
       console.log(test)
   }
   // 现在 callback 的 test 的 string 类型和 Events 中的类型对应上了，就没有报错了。
   ```

### 实现valideinput的验证

1. ValidateForm

   ```ts
   import { defineComponent, onUnmounted } from 'vue'
   import mitt from 'mitt'
   type ValidateFunc = () => boolean
   // 实例化 mitt
   export const emitter = mitt()
   export default defineComponent({
     emits: ['form-submit'],
     setup(props, context) {
       let funcArr: ValidateFunc[] = []
       const submitForm = () => {
         // 循环执行数组 得到最后的验证结果
         const result = funcArr.map(func => func()).every(result => result)
         context.emit('form-submit', result)
       }
       // 将监听得到的验证函数都存到一个数组中
       const callback = (func: ValidateFunc) => {
         funcArr.push(func)
       }
       // 添加监听
       emitter.on('form-item-created', callback)
       onUnmounted(() => {
         // 删除监听
         emitter.off('form-item-created', callback)
         funcArr = []
       })
       return {
         submitForm
       }
     }
   })
   ```

2. ValidateInput

   ```ts
   // 将事件发射出去，其实就是把验证函数发射出去
   onMounted(() => {
     emitter.emit('form-item-created', validateInput)
   })
   ```

### 整个表单的总结

整个登录组件由2个部分构成，一个是validate-form表单容器，一个是validate-input输入组件，输入组件以插槽的形式放在表单容器中，表单容器又放在登录组件中，构成了整个登录页面。

在输入组件中，完成了对输入内容的一个基本验证，规则由登录组件制定，通过props传递给输入组件，输入组件获得规则后依次对输入内容进行验证，对不符合的输入进行不同的提示。

通过两个v-model对输入的内容进行双向绑定。首先是将输入组件中的输入数据响应式处理，使其在输入时数据自动更新。然后在登录组件中的输入组件上进行v-model双向绑定，自定义组件上定义一个变量对输入进行接收，一旦输入发生改变就触发update:modelValue这个事件，将更新的值发送给父组件，从而父组件也获得了更新的值。

validate-form这个容器负责收集填写了几条表单信息，只有每个input都符合验证规则时才可以向服务器发送登录请求。由于在此组件中的自定义组件以插槽的形式存在，无法直接获取组件实例，因此通过自定义事件监听的形式获取所有的验证函数。当点击提交时，会将验证结果发送给登录组件，只有当所有验证均通过时，才会将输入信息传给服务器。

### 什么是 SPA(Single Page Application) 应用？

#### HTML5 History API：

这个 API 帮助我们可以在不刷新页面的前提下动态改变浏览器地址栏中的URL地址，动态修改页面上所显示资源。

 **history.pushState(state, title, url) 方法 ：添加一条历史记录，不刷新页面参数** 

- state : 一个于指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数中。如果不需要这个对象，此处可以填null。
- title : 新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。
- url : 新的网址，必须与前页面处在同一个域。浏览器的地址栏将显示这个网址。

#### SPA的优点

- 速度快，第一次下载完成静态文件，跳转不需要再次下载静态文件
- 体验好，整个交互趋于无缝，更倾向于原生应用
- 为前后端分离提供了实践场所

###  Vue Router 的安装和使用

```shell
npm install vue-router@4
```

```html
<script src="https://unpkg.com/vue@3"></script>
<script src="https://unpkg.com/vue-router@4"></script>

<div id="app">
  <h1>Hello App!</h1>
  <p>
    <!--使用 router-link 组件进行导航 -->
    <!--通过传递 `to` 来指定链接 -->
    <!--`<router-link>` 将呈现一个带有正确 `href` 属性的 `<a>` 标签-->
    <router-link to="/">Go to Home</router-link>
    <router-link to="/about">Go to About</router-link>
  </p>
  <!-- 路由出口 -->
  <!-- 路由匹配到的组件将渲染在这里 -->
  <router-view></router-view>
</div>
```

### `router-link`

请注意，我们没有使用常规的 `a` 标签，而是使用一个自定义组件 `router-link` 来创建链接。这使得 Vue Router 可以在不重新加载页面的情况下更改 URL，处理 URL 的生成以及编码。我们将在后面看到如何从这些功能中获益。

### `router-view`

`router-view` 将显示与 url 对应的组件。你可以把它放在任何地方，以适应你的布局。

### vue-router 添加路由

在main.ts中完成

```ts
import { createApp } from 'vue'
import { createRouter, createWebHistory } from 'vue-router'
import HomeView from './views/HomeView.vue'
import LoginView from './views/LoginView.vue'
import App from './App.vue'
// 创建路由
const routerHistory = createWebHistory()
const router = createRouter({
  // 决定采用的路由类型
  history: routerHistory,
   // 定义路由对应的url和组件 
  routes: [
    {
      path: '/',
      name: 'home',
      component: HomeView
    },
    {
      path: '/login',
      name: 'login',
      component: LoginView
    }
  ]
})
const app = createApp(App)
app.use(router)
app.mount('#app')

```

#### url

![image-20220306094611154](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220306094611154.png)

#### 使用 vue-router 获取参数和跳转路由

```js
import { useRoute } from 'vue-router'
// 它是一个函数，调用后可以返回对应的对象。
const route = useRoute() 
// 我们返回出去，在页面中把它全部显示出来看看
return {
 route
}
// 对于一个object，如果我们想再页面显示它的全部内容，除了在 js 中使用 console，也可以使用 pre 标签包裹这个变量。
// pre 标签可定义预格式化的文本。在pre元素中的文本会保留空格和换行符。文本显现为等宽字体
<pre>{{route}}</pre>

// 替换 URL 为比较丰富的地址
http://localhost:8080/column?abc=foo#123
```

#### 动态路由匹配

实现一个组件中对所有ID不同的用户进行渲染，可以在路径中使用一个动态字段，称之为路径参数

```js
// 这些都会传递给 `createRouter`
const routes = [
  // 动态字段以冒号开始
  { path: '/column/:id', component: ColumnDetail },
]
```

方法一：给to绑定一个对象

```vue
<router-link :to="{name: 'column', params: {id: 'column.id'} }" class="btn btn-outline-primary">进入专栏</router-link>
```

方法二：给to绑定一个模板字符串

```vue
<router-link :to="`/column/${column.id}`" class="btn btn-outline-primary">进入专栏</router-link>
```

#### 路由信息

```js
{
  "path": "/column/1",
  "name": "column",
  "params": {
    "id": "1"
  },
  "query": {},
  "hash": "",
  "fullPath": "/column/1",
  "matched": [
    {
      "path": "/column/:id",
      "name": "column",
      "meta": {},
      "props": {
        "default": false
      },
      "children": [],
      "instances": {},
      "leaveGuards": {
        "Set(0)": []
      },
      "updateGuards": {
        "Set(0)": []
      },
      "enterCallbacks": {},
      "components": {
        "default": {
          "name": "ColumnDetail",
          "__file": "src/views/ColumnDetail.vue",
          "__hmrId": "7e6b15fe"
        }
      }
    }
  ],
  "meta": {}
}
```

#### 使用 useRouter 钩子函数进行跳转

```ts
const router = useRouter()
// 特别注意这个是 useRouter 而不是 useRoute，差一个字母，作用千差万别，那个是获得路由信息，这个是定义路由的一系列行为。在这里，我们可以掉用
router.push('/login') 

// router.push 方法跳转到另外一个 url，它接受的参数和 router-link 的 to 里面的参数是完全一致的，其实router link 内部和这个 router 分享的是一段代码，可谓是殊途同归了。
```

### 添加ColumnDetail页面

#### 添加PostList组件

```vue
<template>
  <div class="post-list">
    <article v-for="post in list" :key="post.id" class="card mb-3 shadow-sm">
      <div class="card-body">
        <h4>{{post.title}}</h4>
        <div class="row my-3 align-items-center">
          <div v-if="post.image" class="col-3">
            <img :src="post.image" :alt="post.title" class="rounded-lg w-100">
          </div>
          <p :class="{'col-9': post.image}">{{post.content}}</p>
        </div>
        <span class="text-muted">{{post.createdAt}}</span>
      </div>
    </article>
  </div>
</template>

<script lang="ts">
import { defineComponent, PropType } from 'vue'
import { PostProps } from '../testData'

export default defineComponent({
  props: {
    list: {
      required: true,
      type: Array as PropType<PostProps[]>
    }
  }
})
</script>
```

#### 完成ColumnDetail逻辑控制

```vue
<template>
  <div class="column-detail-page w-75 mx-auto">
    <div class="column-info row mb-4 border-bottom pb-4 align-items-center" v-if="column">
      <div class="col-3 text-center">
        <img :src="column.avatar" :alt="column.title" class="rounded-circle border ">
      </div>
      <div class="col-9">
        <h4>{{column.title}}</h4>
        <p class="text-muted">{{column.description}}</p>
      </div>
    </div>
    <post-list :list="list"></post-list>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import { testData, testPosts } from '../testData'
import PostList from '../components/PostList.vue'
// 获取路由的信息用useRoute
import { useRoute } from 'vue-router'
export default defineComponent({
  name: 'ColumnDetail',
  components: {
    PostList
  },
  setup () {
    const route = useRoute()
    const currentId = +route.params.id
    // 获取对应id的专栏
    const column = testData.find(c => c.id === currentId)
    // 获取对应专栏的文章
    const list = testPosts.filter(post => post.columnId === currentId)
    return {
      column,
      list
    }
  }
})
</script>
```

## Vuex

### 直接使用全局对象的问题

1. 全局对象里面的数据是普通的 javascript 数据类型，他们不是响应式的，也就说第一次读取渲染有可能没有问题，但是当数据修改以后，**界面没法作出对应的更新**，这是一个很大的问题。
2. 全局对象的修改无法追踪，也就是说在应用中的任何一处代码，都可以有机会拿到全局数据，并作出对应的修改，但是我们根本没有办法搞清楚是哪行代码 哪个文件修改了全局数据，这样就非常**容易产生 bug 而且难以追踪**。
3. vue 是组件化的世界，就像我们的程序大家也可以发现，组件的构成就像一棵树一样，全局数据一般是从父组件一层层的传递给子组件的。直接从一个组件获取数据被视为一种反模式，这样**很容易造成数据的混乱**。

### 状态管理工具

- Vuex ：https://vuex.vuejs.org/zh/guide/
- Redux ：https://redux.js.org/
- Mobx ：https://mobx.js.org/README.html

### 状态管理工具的基本原则

- 一个类似 object 的全局数据结构 - 称之为 store
- 只能调用特定的方法完成数据的修改

### vuex是什么

Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式 + 库**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化

状态自管理应用包含以下几个部分：

- **状态**，驱动应用的数据源；
- **视图**，以声明方式将**状态**映射到视图；
- **操作**，响应在**视图**上的用户输入导致的状态变化。

以下是一个表示“单向数据流”理念的简单示意图：

![image-20220306152715520](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220306152715520.png)

每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：

1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

#### 安装

```sh
npm install vuex@next --save
```

#### 第一次尝试

```ts
// 导入vuex中的createStore方法
import { createStore } from 'vuex'
// 创建一个store仓库
const store = createStore({
    // 初始 state 对象
    state: {
        count: 0
    },
    mutations: {
        add (state) {
            state.count ++
        }
    }
})
// 通过 store.state 来获取状态对象
console.log(store.state.count)
// 通过 store.commit 方法触发状态变更
store.commit('add')
```

### vuex和项目整合

分析：

```ts
// 整个项目的数据
{
    user // 用户
    ColumnProps[] //专栏列表
    PostProps[] //专栏里的文章列表
}
```

1. 创建store

   ```ts
   import { createStore } from 'vuex'
   import { testData, testPosts, ColumnProps, PostProps } from './testData'
   interface UserProps {
     isLogin: boolean;
     name?: string;
     id?: number;
   }
   export interface GlobalDataProps {
     columns: ColumnProps[];
     posts: PostProps[];
     user: UserProps;
   }
   const store = createStore<GlobalDataProps>({
     state: {
       columns: testData,
       posts: testPosts,
       user: { isLogin: false }
     },
     mutations: {
       login(state) {
         state.user = { ...state.user, isLogin: true, name: 'viking' }
       }
     }
   })
   
   export default store
   ```

2. 使用

   - 将store在main.ts中导入

     ```js
     import store from './store'
     ...
     // 将store以插件的形式安装
     app.use(store)
     ```
   
   - HomeView.vue

     ```ts
     import { useStore } from 'vuex'
     import { GlobalDataProps } from '../store'
     
     ...
     // 获取store
     const store = useStore<GlobalDataProps>()
     const list = computed(() => store.state.columns)
     ```
   
   - ColumnDetail.vue
   
     ```ts
     import { computed } from 'vue'
     import { GlobalDataProps } from '../store'
     import { useStore } from 'vuex'
     
     ...
     const store = useStore<GlobalDataProps>()
     const testData = computed(() => store.state.columns)
     const testPosts = computed(() => store.state.posts)
     ```
   
   - App.vue
   
     ```ts
     import { useStore } from 'vuex'
     import { GlobalDataProps } from './store'
     
     ...
     const store = useStore<GlobalDataProps>()
     const currentUser = computed(() => store.state.user)
     ```
   
   - LoginView
   
     ```ts
     import { useStore } from 'vuex'
     import { GlobalDataProps } from '../store'
     
     ...
     const store = useStore<GlobalDataProps>()
     const onFormSubmit = (result: boolean) => {
         if (result) {
             // 页面跳转到首页
             router.push('/')
             // 触发更新用户数据
             store.commit('login')
         }
     }
     ```

### Vuex getters

Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。

使用getter来获取对应的专栏和文章

```ts
getters: {
  biggerColumnsLen(state) {
    return state.columns.filter(c => c.id > 2).length
  }
}
// 定义完毕，就可以在应用中使用这个 getter 了
// Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值：
const biggerColumnsLen =computed(()=>store.getters.biggerColumnsLen)
```

```ts
getters: {
    // biggerColumnsLen 返回一个值
    biggerColumnsLen (state) {
      return state.columns.filter(c => c.id > 2).length
    },
    // getColumnById 返回一个函数
    // getColumnById: (state) => (id: number) => {
    //   return state.columns.find(c => c.id === id)
    // },
    getColumnById (state) {
      return function (id:number) {
        state.columns.find(c => c.id === id)
      }
    },
    getPostsByCid: (state) => (cid: number) => {
      return state.posts.filter(post => post.columnId === cid)
    }
  }

// 定义完毕以后就可以在应用中使用 getter 快速的拿到这两个值了
const column = computed(() => store.getters.getColumnById(currentId))
const list = computed(() => store.getters.getPostsByCid(currentId))
```

总结：

1. `state`：需要管理的全局data
2.  `mutations`：定义改变全局data的方法，**Mutation 必须是同步函数**，采用commit调用mutations中的方法
3.  `actions`：同mutation类似，也是定义修改全局data的方法，不同的是可以进行异步操作，采用dispatch调用
4.  `getters`：可以理解成vuex的computed计算属性，state发生变化他也会同步发生变化
5.  `modules`:可以对vuex的state进行分模块管理

### 添加新建文章页面

1. 创建文章页面

2. 改进validateinput，在props中添加一个tag属性，使得输入框类型可选，在文章页面中使用 tag = ’textarea‘

3. 在store.ts中的mutations中添加createPost方法，传入newPost作为参数

   ```ts
   createPost (state, newPost) {
         state.posts.push(newPost)
       }
   ```

4. 在createPost中onFormSubmit方法中创建一个newPost并调用createPost方法，将newPost传入post列表中

   ```ts
   const onFormSubmit = (result: boolean) => {
       if (result) {
           const columnId = store.state.user.columnId
           if (columnId) {
               const newPost: PostProps = {
                   id: new Date().getTime(),
                   title: titleVal.value,
                   content: contentVal.value,
                   columnId,
                   createdAt: new Date().toLocaleString()
               }
               store.commit('createPost', newPost)
               router.push({ name: 'column', params: { id: columnId } })
           }
       }
   }
   ```

## 添加路由守卫

vue-router 提供的导航守卫主要用来**通过跳转或取消的方式守卫导航**

### 全局前置守卫

一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于**等待中**。

路由元信息：将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的`meta`属性来实现，并且它可以在路由地址和导航守卫上都被访问到

```ts
[{
    path: '/login',
    name: 'login',
    component: LoginView,
    meta: { redirectAlreadyLogin: true }
},
 {
     path: '/create',
     name: 'create',
     component: CreatePost,
     meta: { requiredLogin: true }
 }]

router.beforeEach((to, from, next) => {
    // 若需要登录但没有登录则跳转至登录界面
    if (to.meta.requiredLogin && !store.state.user.isLogin) {
        next({ name: 'login' })
    // 若已经登录还访问登录页面则跳转至首页
    } else if (to.meta.redirectAlreadyLogin && store.state.user.isLogin) {
        next({ name: 'home' })
    } else {
        // 正常跳转
        next()
    }
})
```

## 项目整合后端接口

### 前后端分离开发

![image-20220307095935069](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220307095935069.png)

![image-20220307100034343](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220307100034343.png)

### RESTful 架构详解

#### 什么是RESTful 

REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移

#### 理解RESTful

我们知道 URL 全称为“统一资源定位符（Uniform Resource Locator）”，用于描述 Web 资源所在的位置。RESTful Api 是以 HTTP 协议为强烈依托的，将类似于①和②这种以功能为主导的URL风格舍弃，还原 URL 的本质，它的宗旨就是一个 URL 就应该是一个资源，不能包含任何动作。

```
[POST]   http://mengkang.net/users  // 新增
[GET]   http://mengkang.net/users/1 // 查询
[PATCH]  http://mengkang.net/users/1 // 更新
[PUT]   http://mengkang.net/users/1 // 覆盖，全部更新
[DELETE]  http://mengkang.net/users/1 // 删除
```

#### HTTP请求方法

| 序号 | 方法           | 描述                                                         |
| :--- | :------------- | :----------------------------------------------------------- |
| 1    | GET(SELECT)    | 请求指定的页面信息，并返回实体主体。                         |
| 2    | HEAD           | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| 3    | POST(CREATE)   | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4    | PUT(UPDATE)    | 从客户端向服务器传送的数据取代指定的文档的内容。             |
| 5    | DELETE(DELETE) | 请求服务器删除指定的页面。                                   |
| 6    | PATCH(UPDATE)  | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

#### RESTful架构分析

```js
// endpoints 一串路径，在RESTful中每个路径代表一种资源
http://api.example.com/teams
http://api.example.com/players

// verb
GET /teams: 列出所有球队
POST /teams: 新建一个球队
GET /teams/ID: 获取某个球队的信息
PUT /teams/ID: 更新某个球队的信息（提供球队的全部信息）
PATCH /teams/ID: 更新某个球队的信息（提供球队的部分信息）
DELETE /teams/ID: 删除某个球队

// 复杂结构 一对多
GET　/teams/ID/players: 列出某个指定球队的所有球员

// 常见状态码
// 响应分为五类：100-199 信息响应；200-299 成功响应；300-399 重定向；400-499 客户端错误；500-599 服务器错误
200 OK - [GET]: 服务器成功返回用户请求的数据
201 CREATED - [POST/PUT/PATCH]: 用户新建或修改数据成功
204 NO CONTENT - [DELETE]: 用户删除数据成功

401 Unauthorized -[*]: 表示用户没有权限（令牌，用户名，密码错误）
403 Forbbiden -[*]: 表示用户得到授权但是访问是禁止的
404 NOT FOUND - [*]: 表示用户发出的请求针对的是不存在的记录
```

### 项目架构分析

```
// endpoints

GET /columns: 列出所有专栏
GET /columns/ID: 列出某个专栏的信息
GET /columns/ID/posts: 列出某个专栏的所有文章
POST /columns/ID/posts: 在某个专栏创建文章（需要权限）
GET /posts/ID: 列出某个文章的信息

POST /uesrs/login 用户登录
GET /users/current 获取当前用户登录信息（需要权限）
```

#### 使用后端API

在main.ts中添加默认api

```ts
// 替换 baseURL
axios.defaults.baseURL = 'http://apis.imooc.com/api/'
// 下面的 icode 值是从慕课网获取的 token 值，可以在课程右侧的项目接口校验码找到
axios.interceptors.request.use(config => {
  ... 其他代码
  // get 请求，添加到 url 中
  config.params = { ...config.params, icode: '******' }
  // 其他请求，添加到 body 中
  // 如果是上传文件，添加到 FormData 中
  if (config.data instanceof FormData) {
    config.data.append('icode', '******')
  } else {
  // 普通的 body 对象，添加到 data 中
    config.data = { ...config.data, icode: '******' }
  }
  return config
})
```

### 使用vuex中的action发送异步请求

vuex中的mutation只能进行同步请求，因此使用action完成axios的异步请求

在store.ts中添加方法：

```ts
fetchColumns(context) {
    // 去columns接口取得数据，取得数据后调用fetchColumns方法。将所得数据存储到state中
    axios.get('/columns').then(resp => {
        context.commit('fetchColumns', resp.data)
    }
}
```

在HomeView.vue中调用fetchColumns：

```ts
onMounted(() => {
    // 在DOM元素挂载时调用fetchColumns，发送异步请求获得接口数据
    store.dispatch('fetchColumns')
})
```

同理在ColumnDetail.vue和PostList.vue中执行同样操作

```ts
// 进行异步申请
fetchColumn({ commit }, cid) {
    axios.get(`/columns/${cid}`).then(resp => {
        commit('fetchColumn', resp.data)
    })
},
fetchPosts({ commit }, cid) {
      axios.get(`/columns/${cid}/posts`).then(resp => {
        commit('fetchPosts', resp.data)
      }  
    
// 调用异步请求方法
 onMounted(() => {
      store.dispatch('fetchColumn', currentId)
      store.dispatch('fetchPosts', currentId)
    })
    
```

### 使用async和await改造异步请求

```ts
// 将重复代码合并成一个函数方便调用
const getAndCommit = async (url: string, mutationName: string, commit: Commit) => {
  const { data } = await axios.get(url)
  commit(mutationName, data)
}
// 在actions中调用getAndCommit
actions: {
    fetchColumns ({ commit }) {
      getAndCommit('/columns', 'fetchColumns', commit)
    },
    fetchColumn ({ commit }, cid) {
      getAndCommit(`/columns/${cid}`, 'fetchColumn', commit)
    },
    fetchPost ({ commit }, cid) {
      getAndCommit(`/columns/${cid}/posts`, 'fetchPosts', commit)
    }
  }
```

### 使用axios拦截器添加loading效果

1. 在全局状态中添加loading属性，初始值设为false，在store.ts中的mutations中编写setLoading函数

   ```ts
   setLoading (state, status) {
         state.loading = status
       }
   ```

2. 在App.vue中添加loading显示效果

   ```html
   // 在setup()中计算isloading
   const isloading = computed(() => store.state.loading)
   
   // 添加显示效果
   <h1 v-if= "isloading">正在加载</h1>
   ```

3. 在main.ts中设置axios拦截器，使得每次发送异步请求时都调用setLoading函数，使用interceptors

   ```ts
   // 请求拦截，给每个请求加上特定的参数，提交'setLoading'，修改loading状态，显示loading组件，返回配置
   axios.interceptors.request.use(config => {
     //给访问后端的api设置默认参数
     config.params = { ...config.params, icode: '29128DF1695D4D1D' }
       config.data = { ...config.data, icode: '29128DF1695D4D1D'}
       //调用setLoading
     store.commit('setLoading', true)
     return config
   })
   // 响应拦截，关闭loading组件，返回配置
   axios.interceptors.response.use(config => {
     store.commit('setLoading', false)
     return config
   })
   ```

### 完成loader组件

1. 基本实现

   ```vue
   <template>
     <div
     class="d-flex justify-content-center align-items-center h-100 loading-container"
     :style="{backgroundColor: background || ''}"
     >
       <div class="loading-content ">
         <div class="spinner-border text-primary" role="status">
         <span class="visually-hidden">Loading...</span>
         </div>
         <p v-if="text" class="text-primary small">{{text}}</p>
       </div>
     </div>
   </template>
   
   <script lang='ts'>
   import { defineComponent } from 'vue'
   export default defineComponent({
     name: 'LoaderComponent',
     // 自定义文本内容和背景颜色
     props: {
       text: {
         type: String
       },
       background: {
         type: String
       }
     }
   })
   </script>
   
   <style>
     .loading-container {
       background: rgba(255, 255, 255, 0.5);
       z-index: 100;
       position: fixed;
       width: 100%;
       height: 100%;
       top: 0;
       left: 0;;
     }
     .loading-container {
       text-align: center;
     }
   </style>
   
   ```

2. 使用teleport将组件挂载到独立于app以外，并且在setup中创建DOM节点实例，在onUnmounted时销毁节点

   ```vue
   <template>
   <teleport to='#back'>
     <div
     class="d-flex justify-content-center align-items-center h-100 loading-container"
     :style="{backgroundColor: background || ''}"
     >
       <div class="loading-content ">
         <div class="spinner-border text-primary" role="status">
         <span class="visually-hidden">Loading...</span>
         </div>
         <p v-if="text" class="text-primary small">{{text}}</p>
       </div>
     </div>
   </teleport>
   </template>
   
   <script lang='ts'>
   import { defineComponent, onUnmounted } from 'vue'
   export default defineComponent({
     name: 'LoaderComponent',
     props: {
       text: {
         type: String
       },
       background: {
         type: String
       }
     },
     setup () {
       // 生成DOM节点
       const node = document.createElement('div')
       node.id = 'back'
       document.body.appendChild(node)
       onUnmounted(() => {
         document.body.removeChild(node)
       })
     }
   })
   </script>
   
   <style>
     .loading-container {
       background: rgba(255, 255, 255, 0.5);
       z-index: 100;
       position: fixed;
       width: 100%;
       height: 100%;
       top: 0;
       left: 0;;
     }
     .loading-container {
       text-align: center;
     }
   </style>
   
   ```
   
3. 在App中引入loaderComponent

   ```html
   <loader-component v-if="loading" text="拼命加载中" background="rgba(0,0,0,0.8)"></loader-component>
   
   // 获取loading的状态
   loading = computed(()=> store.state.loading)
   ```

## 登录部分

### 完成login异步请求

1. 完成登录的过程就是发送POST请求，发送邮箱和密码，在用户名和密码匹配的情况下，后端创建一个持久化的会话，然后将一个特别的标识符传给前端，首先在store.ts中添加login的异步请求

   ```ts
   // 创建一个用于post请求的函数
   const postAndCommit = async (url: string, mutationName: string, commit: Commit, payload: unknown) => {
       const { data } = await axios.post(url, payload)
       commit(mutationName, data)
       return data
   }
   
   // 获取token
   login ({ commit }, payload) {
       return postAndCommit('/user/login', 'login', commit, payload)
   }
   
   // 将token放入state中
   login (state, rawData) {
       state.token = rawData.data.token
   }
   ```

2. 点击登录时传入payload，触发login

   ```ts
   const onFormSubmit = (result: boolean) => {
       if (result) {
           const payload = {
               email: emailVal.value,
               password: passwordVal.value
           }
           store.dispatch('login', payload).then(data => {
               console.log(data)
               router.push('/')
           })
       }
   }
   ```

### 关于jwt(JSON WEB TOKEN)的使用

#### 基于cookie session的解决方案

1. 首先浏览器向服务器发送login申请包含用户名和密码，服务器验证用户名和密码
2. 如果验证通过则创建对应的session数据并保存在内存或者数据库中，保存完毕后发送一个200 OK的HTTP response，这个response中一般有个Set-cookie的header，其中包含此session的唯一id
3. 浏览器接收到这个response之后，将cookie存储在浏览器中，在下次要访问这个需要权限的接口时，自动带上这个cookie中的sessionId。
4. 服务器端收到请求以后，使用cookie中的信息查看服务器中是否存在该session的数据
5. 如果存在则返回200 OK
6. 如果不存在则返回401 表示没有访问权限

#### 基于session认证所显露的问题

**Session**: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。

**扩展性**: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。

**CSRF**: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到**跨站请求伪造**的攻击。

![image-20220308185914430](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220308185914430.png)

#### 基于token的鉴权机制

基于token的鉴权机制类似于http协议也是无状态的，它**不需要**在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。

流程上是这样的：

- 用户使用用户名密码来请求服务器
- 服务器进行验证用户的信息
- 服务器通过验证使用JWT算法发送给用户一个token
- 客户端存储token，常见存储在 localStorage或sessionStorage中，并在每次请求时附送上这个token值
- 服务端验证token值，并返回数据

![image-20220308191744616](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220308191744616.png)

### 整个实现登录的过程

1. 创建一个用于发起post请求的异步函数，通过身份验证后，服务端返回一个token数据，接收这个token并通过commit login这个函数，将token保存至state中，并将token添加到http请求的头部信息中
2. 再次发起一个get请求的异步函数，头部携带token，请求当前用户的详细信息。服务器返回信息，更新store中的user状态，跟它相关联的页面信息同步更新
3. 为了实现持久登录，将token通过localStorage.setItem('token',token)，存在本地，关闭浏览器后，token也不丢失，将store中的token初始化为localStorage.getItem('token')在app挂载时，自动添加token在头部，并发送get请求获取当前用户信息

### axios设置通用header

1. 访问login这个url获取token

   ```ts
   // 创建一个用于post请求的函数
   const postAndCommit = async (url: string, mutationName: string, commit: Commit, payload: unknown) => {
       const { data } = await axios.post(url, payload)
       commit(mutationName, data)
       return data
   }
   
   // 获取token
   login ({ commit }, payload) {
       return postAndCommit('/user/login', 'login', commit, payload)
   }
   
   // 将token放入state中
   login (state, rawData) {
       state.token = rawData.data.token
   }
   ```

2. 设置通用的authorization header

   ```ts
   login (state, rawData) {
         const { token } = rawData.data
         state.token = rawData.data.token
         // 完成请求头设置
         axios.defaults.headers.common.Authorization = `Bearer ${token}`
       }
   ```

3. 获取用户信息访问current url，更新store并且显示到页面

   ```ts
   mutations: {
       ...
       fetchCurrentUser (state, rawData) {
         state.user = { isLogin: true, ...rawData.data }
       }
   }
   actions: {
   	...
   	fetchCurrentUSer ({ commit }) {
         // 获取当前用户信息
         return getAndCommit('/user/current', 'fetchCurrentUser', commit)
       }
   }
   ```

#### 使用组合action

特别注意 action 中要把 promise 返回出去，这样才能在调用的时候拿到对应的数据

```ts
loginAndFetch ({ dispatch }, loginData) {
      return dispatch('login', loginData).then(() => {
        return dispatch('fetchCurrentUser')
      })
    }
```

### 持久化登录

3种选择：cookie（不支持跨域）、localStorage、sessionStorage

![image-20220308203505984](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220308203505984.png)

1. 在store初始化token

   ```ts
   // 初始化token
   token: localStorage.getItem('token') || ''
   // 存储token
   login (state, rawData) {
       const { token } = rawData.data
       state.token = rawData.data.token
       localStorage.setItem('token', token)
       // 完成请求头设置
       axios.defaults.headers.common.Authorization = `Bearer ${token}`
   }
   ```

2. 在app.vue 中判断

   ```ts
   const token = computed(() => store.state.token)
   onMounted(() => {
       // 如果存在
       if (token.value && !currentUser.value.isLogin) {
           // 自动补全header
           axios.defaults.headers.common.Authorization = `Bearer ${token.value}`
           // 获取当前用户信息
           store.dispatch('fetchCurrentUser')
       }
   })
   ```

### 通用错误处理

在main.ts中设置axios的拦截器

```ts
axios.interceptors.response.use(config => {
  setTimeout(() => { store.commit('setLoading', false) }, 1000)
  return config
}, e => {
  console.log(e.response)
  const { error } = e.response.data
  // 如果有错误就将错误设置在store的state中
  store.commit('setError', { status: true, message: error })
  store.commit('setLoading', false)
  return Promise.reject(e.response.data)
})
```

### 创建Message组件

```vue
<template>
  <teleport to='#message'>
    <div class="alert message-info fixed-top w-50 mx-auto d-flex justify-content-between mt-2" :class="classObject" v-if="isVisible">
    <span>{{message}}</span>
    <button type="button" class="btn-close" @click.prevent="hide" aria-label="Close"></button>
</div>
  </teleport>
</template>

<script lang="ts">
import { defineComponent, PropType, ref } from 'vue'
import useDOMCreate from '../hooks/useDOMCreate'
// 定义消息类型
export type MessageType = 'success' | 'error' | 'default'
export default defineComponent({
  props: {
    message: String,
    type: {
      type: String as PropType<MessageType>,
      default: 'default'
    }
  },
  // 设置一个自定义事件
  emits: ['close-message'],
  setup (props, context) {
    // 创建一个DOM节点
    useDOMCreate('message')
    const isVisible = ref(true)
    const classObject = {
      'alert-success': props.type === 'success',
      'alert-danger': props.type === 'error',
      'alert-primary': props.type === 'default'
    }
    const hide = () => {
      isVisible.value = false
        // 自定义事件便于拿到生命周期
      context.emit('close-message', true)
    }
    return {
      classObject,
      isVisible,
      hide
    }
  }
})
</script>

<style>

</style>

```

#### 使用函数创建组件实例

message组件嵌套在组件树中显示不合适，他应该像一个函数一样调用时显示，点击关闭或定时消失

学习使用createApp方法创建组件实例，并将实例挂载到真实DOM节点上

```ts
import MessageAlert from './MessageAlert.vue'
// createApp生成组件实例
import { createApp } from 'vue'
export type MessageType = 'success' | 'error' | 'default'

const createMessage = (message: string, type: MessageType, timeout = 2000) => {
    // 第一个参数是组件本身，第二个是props
  const messageInstance = createApp(MessageAlert, {
    message,
    type
  })
  // 新建一个dom节点
  const mountNode = document.createElement('div')
  // 将dom节点添加到文档
  document.body.appendChild(mountNode)
  // 将组件实例挂载到DOM节点上
  messageInstance.mount(mountNode)
  setTimeout(() => {
      // 从节点卸载组件
    messageInstance.unmount()
    document.body.removeChild(mountNode)
  }, timeout)
}

export default createMessage
```

### 注册页面的编写

与login类似，但是在validateInput中需要添加一个新的类型'custom'，来完成重复输入密码的判断

```ts
case 'custom': {
    passed = rule.validator ? rule.validator() : true
    break
}
```

在注册页面写下判定规则

```ts
const repeatPasswordRules: RuleProps = [
    { type: 'required', message: '重复密码不能为空' },
    {
        type: 'custom',
        validator: () => {
            return formData.password === formData.repeatPassword
        },
        message: '密码不相同'
    }
]
```

提交表单，实现登陆跳转功能

```ts
const onFormSubmit = (result: boolean) => {
    if (result) {
        const payload = {
            email: formData.email,
            nickName: formData.nickName,
            password: formData.password
        }
        axios.post('/users/', payload).then(data => {
            createMessage('注册成功 2秒以后跳转登陆页面', 'success')
            setTimeout(() => {
                router.push('/login')
            }, 2000)
        }).catch(e => {
            console.log(e)
        })
    }
}
```

点击退出登录实现退出跳转

```ts
// store.ts中添加mutations
logout (state) {
    state.token = ''
    state.user = { isLogin: false }
    localStorage.removeItem('token')
    delete axios.defaults.headers.common.Authorization
}

// Global Header点击退出登陆时调用logout()
setup () {
    const router = useRouter()
    const handleLogout = () => {
        store.commit('logout')
        createMessage('退出登录成功，2秒后跳转到首页', 'success', 2000)
        setTimeout(() => {
            router.push('/')
        }, 2000)
    }
    return {
        handleLogout
    }
}
```

## 上传组件

![image-20220309153734343](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220309153734343.png)

整个流程：

```html
<uploader
	action = "http://upload"
    beforeUpload=""
    @uploading=""
    @fileUploaded=""
    @uploadedError=""
>
    <button/>
    <template #uploaded></template>
    <template #loading></template>
</uploader>
```

### 上传文件的两种实现方式

```html
<!-- 设置enctype="multipart/form-data" ，设置内容类型-->
<form action="/api" enctype="multipart/form-data">
    <!-- 渲染出一个可以选择文件的对话框 -->
    <input type="file" name="file">
    <!-- 表单的默认行为，点击提交，发送一个httprequest到action的url -->
    <button type="submit">
    </button>
</form>
```

在createPost组件中添加使用input上传文件的代码：

```vue
<template>
<input type="file" name="file" @change.prevent="handleFileChange" />
</template>
<script>
    export default defineComponent({
        ...
        setup(){
        const handleFileChange = (e:Event) => {
        // 断言成HTMLInputElement可以方便拿到里面的属性
        const target = e.target as HTMLInputElement
        // 获得上传的files，files是一个伪数组，里面可能有多个文件
        const files = target.files
        if (files) {
            // 拿到他的第一项
            const uploadedFile = files[0]
            // FormData对象用以将数据编译成键值对，以便用XMLHttpRequest来发送数据
            const formData = new FormData()
            // 并通过调用 append 方法为其附加了 <input> 值
            formData.append(uploadedFile.name, uploadedFile)
            // 发送post请求
            axios.post('/upload', formData, {
                // 加入特殊头部表明内容类型
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            }).then((resp:unknown) => {
                console.log(resp)
            })
        }
    }
    }
    })
</script>
```

### 创建UpLoader组件

**采用点击按钮，操作一个隐藏的input节点，完成上传功能**

```vue
<template>
  <div class="file-upload"></div>
    <button class="btn btn-primary" @click.prevent="triggerUpload">
        <span v-if="fileStatus === 'loading'">正在上传</span>
        <span v-else-if="fileStatus === 'success'">上传成功</span>
        <span v-else-if="fileStatus === 'error'">上传失败</span>
        <span v-else>点击上传</span>
    </button>
    <input type="file" class="file-input d-none" ref="fileInput" @change="handleFileChange">
</template>

<script lang="ts">
import axios from 'axios'
import { defineComponent, ref } from 'vue'
type UploaderStatus = 'ready' | 'loading' | 'success' | 'error'
export default defineComponent({
  props: {
    action: {
      type: String,
      required: true
    }
  },
  setup () {
    const fileInput = ref<null | HTMLInputElement>(null)
    const fileStatus = ref<UploaderStatus>('ready')
    const triggerUpload = () => {
        // 如果已有上传数据，则自动触发点击事件
      if (fileInput.value) {
        fileInput.value.click()
      }
    }
    const handleFileChange = (e:Event) => {
      const currentTarget = e.target as HTMLInputElement
      const files = currentTarget.files
      if (files) {
        fileStatus.value = 'loading'
        const uploadedFile = files[0]
        const formData = new FormData()
        formData.append(uploadedFile.name, uploadedFile)
        axios.post('/upload', formData, {
          // 加入特殊头部表明内容类型
          headers: {
            'Content-Type': 'multipart/form-data'
          }
        }).then((resp) => {
          // 上传成功
          console.log(resp.data)
          fileStatus.value = 'success'
        }).catch(() => {
          // 上传失败
          fileStatus.value = 'error'
        }).finally(() => {
          if (fileInput.value) {
            // 清空上传的内容
            fileInput.value.value = ''
          }
        })
      }
    }
    return {
      fileInput,
      triggerUpload,
      fileStatus,
      handleFileChange
    }
  }
})
</script>

<style>

</style>
```

#### 设置beforeUpload

在uploader组件中设置一个props，在父组件中设置beforeUpload,，用来判断上传内容是否符合标准

```ts
const beforeUpload = (file: File) => {
    const isJPG = file.type === 'image/jpeg'
    if (!isJPG) {
        createMessage('图片只支持jpeg格式', 'error')
    }
    return isJPG
}
```

#### 设置file-uploade、file-uploaded-error事件

在uploader组件中自定义事件file-uploaded，当数据成功上传时就触发file-uploaded（上传失败时就触发file-uploaded-error），且将返回的数据发送给父组件，父组件调用方法创建弹窗

```html
// uploader组件
<script>
    emits: ['file-uploaded', 'file-uploaded-error']
    axios.post(props.action, formData, {
        // 加入特殊头部表明内容类型
        headers: {
            'Content-Type': 'multipart/form-data'
        }
    }).then((resp) => {
        context.emit('file-uploaded', resp.data)
        uploadedData.value = resp.data
        fileStatus.value = 'success'
    }).catch((error) => {
        fileStatus.value = 'error'
        console.log(error)
        context.emit('file-uploaded-error', { error })
    }).finally(() => {
        if (fileInput.value) {
            fileInput.value.value = ''
        }
    })
</script>
// 父组件
<up-loader action="/upload" :beforeUpload="beforeUpload"  @file-uploaded="onFileUploaded" @file-uploaded-error="onFileUploadedError">
    <template #uploaded="dataProps">
        <img :src="dataProps.uploadedData.data.url" width="500">
    </template>
</up-loader>

<script>
    const onFileUploaded = (rawData: ResponseType<ImageProps>) => {
        createMessage(`上传图片ID ${rawData.data._id}`, 'success')
    }
    const onFileUploadedError = (rawData: ResponseErrorType) => {
        createMessage(`上传失败 原因${rawData.error}`, 'error')
    }
</script>
```



#### 自定义模板

使用具名插槽，当想更改默认内容时使用 `<template v-slot:name>`或者 `<template #name>`

```html
<template>
  <div class="file-upload">
    <div class="file-upload-container" @click.prevent="triggerUpload">
      <slot v-if="fileStatus === 'loading'" name="loading">
        <button class="btn btn-primary" disabled>正在上传...</button>
      </slot>
      <slot v-else-if="fileStatus === 'success'" name="uploaded" :uploadedData="uploadedData">
        <button class="btn btn-primary">上传成功</button>
      </slot>
      <slot v-else name="default">
        <button class="btn btn-primary">点击上传</button>
      </slot>
    </div>
    <input type="file" class="file-input d-none" ref="fileInput" @change="handleFileChange">
  </div>
</template>
```

### 改进路由验证系统

![image-20220309195354127](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220309195354127.png)

```ts
router.beforeEach((to, from, next) => {
  const { user, token } = store.state
  const { requiredLogin, redirectAlreadyLogin } = to.meta
  // 判断是否已经登录
  if (!user.isLogin) {
    // 没有登录则判断是否有token值
    if (token) {
      // 如果有，则发送异步请求获得当前用户信息
      axios.defaults.headers.common.Authorization = `Bearer ${token}`
      store.dispatch('fetchCurrentUser').then(() => {
        // 如果在登录页面则返回首页
        if (redirectAlreadyLogin) {
          next('/')
        } else {
          // 如果不在则正常跳转
          next()
        }
      }).catch(e => {
        // 如果有token值但无法获取当前用户信息，则说明token过期需重新登陆
        console.log(e)
        localStorage.removeItem('token')
      })
    } else {
      // 如果没有token值，但在需要登录权限的页面则跳转至登录
      if (requiredLogin) {
        next('login')
      } else {
        // 正常跳转
        next()
      }
    }
  } else {
    // 已经登录，则判断是否在登录页面
    if (redirectAlreadyLogin) {
      // 在登录页面则跳转到首页
      next('/')
    } else {
      // 正常跳转
      next()
    }
  }
})
```

### 创建文章页面实现

将uploader组件引入，编写helper.ts，引入beforeUploadCheck方法设置上传规则

```ts
// beforeUploadCheck
interface CheckCondition {
  format?: string[],
  size?: number
}
type ErrorType = 'size' | 'format' | null
export function beforeUploadCheck (file: File, condition: CheckCondition) {
  const { format, size } = condition
  const isValidFormat = format ? format.includes(file.type) : true
  const isValidSize = size ? (file.size / 1024 / 1024 < size) : true
  let error: ErrorType = null
  if (!isValidFormat) {
    error = 'format'
  }
  if (!isValidSize) {
    error = 'size'
  }
  return {
    passed: isValidFormat && isValidSize,
    error
  }
}
```

```ts
// 触发file-upload事件时，判断上传条件
const uploadCheck = (file: File) => {
    const result = beforeUploadCheck(file, {
        format: ['image/jpg', 'image/png', 'image/jpeg'], size: 1
    })
    const { passed, error } = result
    if (error === 'format') {
        createMessage('仅支持JPG/PNG格式的图片', 'error')
    }
    if (error === 'size') {
        createMessage('图片大小不能超过1Mb', 'error')
    }
    return passed
}
// 具体流程看代码
```

### 完成文章详情页面 

#### 功能需求

点击 column 页面中的某篇文章标题，跳转到文章详情页面 ( post )，文章详情页面依次展示文章头图，文章标题，作者信息，markdown 格式的文章内容。  

#### 关键点分析

1. 跳转到 post 页面时，怎么拿到相应的 post id；

   根据路由信息中的 PostId 发送 GET 到/posts/${id}获取单个 Post

2. 头图没有时怎么显示

3.  怎么解析展示 markdown 格式的文章内容。  

#### 编码流程

1. 创建相应的 view 和 router。 
2. 从 router 拿到 post id 发送请求拿到 post 数据。 
3. 判断头图是否存在。 
4. 简单展示作者信息。
5. 导入 md 解析插件。 
6. 调用 md 插件解析展示文章内容。 
7. 完善作者信息展示，以小卡片的形式展示，抽象成组件以复用。 
8. 完善整个页面。
9. 检查 bug 等等。

![image-20220309223706925](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220309223706925.png)

## 编辑和删除文章

### 编辑文章

可以用给路由添加参数的方式使用createPost页面实现编辑功能

```ts
const route = useRoute()
const isEditMode = !!route.query.id
onMounted(() => {
    // 判断是否是编辑模式
    if (isEditMode) {
        // 触发异步请求获取当前文章内容
        store.dispatch('fetchPost', route.query.id).then((rawDate: ResponseType<PostProps>) => {
            // 存储获得的数据
            const currentPost = rawDate.data
            // 如果存在上传的图片
            if (currentPost.image) {
                // 则将上传图片显示出来
                uploadedData.value = { data: currentPost.image }
            }
            // 更新的值没有被inputVal获取，尝试添加watch
            titleVal.value = currentPost.title
            contentVal.value = currentPost.content || ''
        })

    })
```

```ts
// 当键入时，watch会被持续触发
watch(() => props.modelValue, (newValue) => {
      inputRef.val = newValue || ''
    })
```

![image-20220310155646457](C:\Users\Sagittarius\AppData\Roaming\Typora\typora-user-images\image-20220310155646457.png)

采用计算属性中的set实现

```ts
const inputRef = reactive({
      val: computed({
        get: () => props.modelValue || '',
        set: (val) => {
          context.emit('update:modelValue', val)
        }
      }),
      error: false,
      message: ''
})
```

发送异步请求的重构和优化

```ts
// store.ts
import axios, { AxiosRequestConfig } from 'axios'
// 可以根据需求更改axios的请求类型
const asyncAndCommit = async (url: string, mutationName: string, commit: Commit, config: AxiosRequestConfig = { method: 'get' }) => {
    const { data } = await axios(url, config)
    commit(mutationName, data)
    return data
}
// 设置更新文章的action方法
updatePost ({ commit }, { id, payload }) {
    return asyncAndCommit(`/posts/${id}`, 'updatePost', commit, {
        method: 'patch',
        data: payload
    })
}
// 设置更新文章的mutation方法
updatePost (state, rawData) {
    state.posts = state.posts.map(post => {
        if (post._id === rawData.data.id) {
            return rawData.data
        } else {
            return post
        }
    })
}

// createPost.vue
// 判断当前模式，发送不同类型的请求
const actionName = isEditMode ? 'updatePost' : 'createPost'
const sendData = isEditMode
? {
    id: route.query.id,
    payload: newPost
}
: newPost
// 发送post请求，发表文章，成功后跳转到专栏详情
store.dispatch(actionName, sendData).then(() => {
    createMessage('发表成功，2秒后跳转到文章', 'success', 2000)
    setTimeout(() => {
        router.push({ name: 'column', params: { id: column } })
    }, 2000)
})
```

### 删除文章

点击删除文章应该弹出一个提示框，因此编写一个modal组件

#### modal组件

分析：

```html
<modal title="hello" :visible="true/false"
       @modal-on-confirm=""
       @modal-on-close="">
    <p>
        content here
    </p>
</modal>
```

#### 删除详情

```vue
<template>
<teleport to='#modal'>
  <div class="modal d-block" tabindex="-1" v-if="visible">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">{{title}}</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" @click="onClose"></button>
      </div>
      <div class="modal-body">
        <!-- 自定义内容 -->
        <slot></slot>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" @click="onClose">取消</button>
        <button type="button" class="btn btn-primary" @click="onConfirm">确定</button>
      </div>
    </div>
  </div>
</div>
</teleport>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import useDOMCreate from '@/hooks/useDOMCreate'
export default defineComponent({
  name: 'ModalAlert',
  props: {
    title: String,
    visible: {
      type: Boolean,
      default: false
    }
  },
  // 创建自定义事件
  emits: ['modal-on-close', 'modal-on-confirm'],
  setup (props, context) {
    useDOMCreate('modal')
    const onClose = () => {
      // 点击时触发modal-on-close自定义事件
      context.emit('modal-on-close')
    }
    const onConfirm = () => {
      // 点击时触发modal-on-confirm自定义事件
      context.emit('modal-on-confirm')
    }
    return {
      onClose,
      onConfirm
    }
  }
})
</script>
```

```ts
// 事件modal-on-confrim绑定删除的异步请求
const hideAndeDelete = () => {
    // 关闭弹窗
    modalIsVisible.value = false
    // 触发删除文章的异步请求
    store.dispatch('deletePost', currentId).then((rawData: ResponseType<PostProps>) => {
        createMessage('删除成功，2秒之后跳转到专栏首页', 'success', 2000)
        setTimeout(() => {
            router.push({ name: 'column', params: { id: rawData.data.column } })
        }, 2000)
    })
}
```

## 持续优化

flatten state、normalization state shape

将store里的数据类型转换为对象（根据关键码值(Key:_id  value)而直接进行访问的数据结构）

优点：减少遍历数组的操作

ts中的indexable Types：`[index: string] : string`

map()：对数组的每个元素调用定义的回调函数并返回包含结果的数组。

```js
array.map(function(currentValue, index, arr), thisIndex)
```

**参数说明：**

- `function(currentValue, index, arr)`：**必须**。为一个函数，数组中的每个元素都会执行这个函数。其中函数参数：

> 1. `currentValue`：**必须**。当前元素的的值。
> 2. `index`：**可选**。当前元素的索引。
> 3. `arr`：**可选**。当前元素属于的数组对象。

- `thisValue`：**可选**。对象作为该执行回调时使用，传递给函数，用作"`this`"的值。

### 数组到object的变形

#### reduce方法

1. reduce(callback,initialValue)会传入两个变量，回调函数(callback)和初始值(initialValue)。
2. 假设函数有4个传入参数，prev和next，index和array。 prev和next是你必须要了解的。
3. 当没有传入初始值时，prev是从数组中第一个元素开始的，next数组是第二个元素。
4. 但是当传入初始值（initialValue）后,第一个prev将是initivalValue，next将是数组中的第一个元素

```ts
// 添加一个数组泛型，对应得时TestProps类型
export const arrToObj = <T extends ColumnProps | PostProps >(arr : Array<T>) => {
  return arr.reduce((prev, current) => {
    if (current._id) {
      prev[current._id] = current
    }
    return prev
    // 进行类型断言将类型断言成testData2的类型
  }, {} as { [key: string]: T})
}
```

### object到数组的变形

Object.keys(obj)

参数：要返回其枚举自身属性的对象

返回值：一个表示给定对象的所有可枚举属性的字符串数组

```ts
export const objToArr = <T>(obj: {[key: string]: T}) => {
  return Object.keys(obj).map(key => obj[key])
}
```

### 防止重复请求逻辑分析

```ts
interface GlobalColumns {
	data: ListProps<ColumnsProps>,
    // 标识请求是否完成
    isLoaded: boolean    
}
// 加载column列表信息
./Columns
columns.isLoaded
// 加载某个专栏的详细信息
/columns/${id}
columns.data[id]
// post列表与专栏id相关
interface GlobalPosts {
    data: ListProps<PostProps>
    loadedColumns: string[]
}
/Columns/${cid}/posts
// 判断已加载的专栏中是否包含cid专栏
posts.loadedColumns.includes(cid)
/post/${id}
posts.data[id]
```

#### 代码实现

```ts
...
// 初始化数据
columns: { data: {}, isLoaded: false, total: 0 },
posts: { data: {}, loadedColumns: [] },
    
actions: {
    fetchColumns ({ state, commit }) {
      const { currentPage = 1, pageSize = 6 } = params
      // 如果state中的columns中的isloaded字段不为true，则发送异步申请
       if (!state.columns.isLoaded) {
        return getAndCommit('/columns', 'fetchColumns', commit)
      } 
    },
    fetchColumn ({ state, commit }, cid) {
      // 如果cid对用的专栏数据不存在则发送异步请求
      if (!state.columns.data[cid]) {
        return getAndCommit(`/columns/${cid}`, 'fetchColumn', commit)
      }
    },
    fetchPosts ({ state, commit }, cid) {
      // 如果文章列表中的已加载专栏中不包含cid，则发送异步请求
      if (!state.posts.loadedColumns.includes(cid)) {
        return asyncAndCommit(`/columns/${cid}/posts`, 'fetchPosts', commit, { method: 'get' }, cid)
      }
    },
    fetchPost ({ state, commit }, id) {
      const currentPost = state.posts.data[id]
      // 如果已经取过了post就不会返回promise对象，因此要人工返回一个promise对象
      if (!currentPost || !currentPost.content) {
        return asyncAndCommit(`/posts/${id}`, 'fetchPost', commit)
      } else {
        return Promise.resolve({ data: currentPost })
      }
    },
},
mutations: {
     fetchColumns (state, rawData) {
      // 获取已有的专栏数据
      const { data } = state.columns
      // 获取返回数据中的列表和数量
      const { list, count } = rawData.data
      // 更新state中专栏列表信息
      state.columns = {
        // 使用扩展运算符将原有信息和新获取的数据连接起来
        data: { ...data, ...arrToObj(list) },
        total: count,
        // 更改专栏列表状态为已加载
        isLoaded: true
      }
    },
    fetchColumn (state, rawData) {
      state.columns.data[rawData.data._id] = rawData.data
    },
    fetchPosts (state, { data: rawData, extraData: columnId }) {
      // 使用展开操作符不断添加数据
      state.posts.data = { ...state.posts.data, ...arrToObj(rawData.data.list) }
      state.posts.loadedColumns.push(columnId)
    },
    fetchPost (state, rawData) {
      state.posts.data[rawData.data._id] = rawData.data
      console.log(rawData.data)
    },
}
```

### useLoadMore实现分析

```ts
// 自定义函数
// 1.确定它的参数
function useLoadMore(actionName, params) {
	// 3. 确定函数实现
    const loadMorePage = () => {
        store.dispatch()
    }
    const isLastPage = computed (() => {
        Math.ceil(total/pageSize) ===currentPage
    })
	// 2.确定他的返回
	// 需要返回一个函数，让用户去在他想要的逻辑中加载
	// 然后还有一个变量，指示是否是最后一页
	return {
		loadMorePage,
        isLastPage
	}
}
```

## 项目构建和部署

1. npm run build，用webpack打包

2. 使用giteepages部署：（只是将前端页面进行部署）

   1. 首先登录gitee，创建一个和自己用户名一样的仓库
   2. 将仓库git下来将npm run build 好的dist里的内容push上去
   3. 点击服务选择giteepages创建链接

3. 使用nginx部署：

   1. 去nginx官网下载zip包并解压

   2. cmd进入nginx路径，启动nginx 

      ```sh
      start nginx
      ```

      关闭niginx

      ```
      nginx -s stop
      ```

   3. 静态文件的配置

      将build好的文件全部复制到 `D:\Program Files\nginx-1.20.2\html`，配置好后打开浏览器进入localhost:80端口可以看到静态页面
